<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
<head>
	<title>Obsah</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" href="../style/default.css" type="text/css" />
	<link rel="stylesheet" href="../style/main.css" type="text/css" />
</head>

<body>

<h1>4 Počítače s jedným prúdom inštrukcií a jedným prúdom údajov</h1><p>V tejto kapitole sa budeme zaoberať von Neumannovským počítačom. Podrobne opíšeme jeho jednotlivé podsystémy a ich vzájomné vzťahy.</p><h2>4.1 Prepojovací podsystém počítača</h2><p><strong><em>Prepojovací podsystém počítača</em></strong> slúži na prepojenie jednotlivých častí počítača, t.j. umožňuje procesoru načítanie inštrukcií a údajov z pamäte, zápis výsledkov do pamäte, načítanie údajov zo vstupného zariadenia a výstup výsledkov prostredníctvom výstupného zariadenia. Okrem toho môže umožňovať aj priamy prenos údajov medzi pamäťou a vstupným, resp. výstupným zariadením.<br />Spôsoby prepojenia jednotlivých častí počítača sú v zásade dva - prepojenie pomocou <em>prepojovacích kanálov</em> a prepojenie prostredníctvom <em>zbernice.</em></p><p><strong>Prepojovací kanál</strong><br /><strong><em>Prepojovací kanál</em></strong> je <em>špecializované spojenie</em> medzi dvoma blokmi počítača, napr. počítač z obr. 1 má <em>tri</em> prepojovacie kanály - prvý slúži na spojenie procesora s pamäťou, druhý na spojenie procesora so vstupným a tretí na spojenie s výstupným zariadením. Kanály pre priamy prenos údajov medzi pamäťou a vstupným, resp. výstupným zariadením tohto konkrétneho počítača nie sú realizované. Kanál predstavuje spojenie dvoch zariadení, kde je jednoznačne určené, ktoré z nich bude riadiť prenos. V našom prípade je týmto prvkom procesor. Vzhľadom na komplikovanosť prepojovacieho systému pri takomto riešení (pripojenie každého ďalšieho zariadenia si vyžaduje realizovať nový kompletný kanál) sa toto riešenie v súčasnosti používa len v špeciálnych prípadoch. V ďalšom sa preto budeme podrobnejšie venovať <em>zbernicovému prepojovaciemu systému.</em></p><h3>4.1.1 Zbernica</h3><p><strong><em>Zbernica</em></strong> je množina liniek (vodičov), ktorá navzájom prepája <em>všetky prvky na danej štruktúrnej úrovni.</em> Umožňuje spojenie každého s každým, ale v danom okamihu môže údaje na zbernicu vysielať iba jediné zariadenie. Ostatné zariadenia, schopné vysielať údaje na zbernicu, musia byť vtedy od zbernice odpojené. Reálne sa to uskutoční takým spôsobom, že uvedú svoje výstupy do stavu vysokej impedancie (pozri časť 3.7.4).</p><p><strong><em>Zbernica počítača</em></strong> navzájom prepája procesor, pamäť, vstupné a výstupné zariadenia. Na obr. 4.1 je nakreslený počítač so zbernicovou architektúrou.</p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/Obr_21.png" border="0" alt="21" width="650" height="138" /></div><p align="center">OBR. 4.1 Počítač so zbernicovou architektúrou </p><h4>4.1.1.1 Rozdelenie zberníc</h4><p><strong>Podľa spôsobu riadenia:</strong></p><ul><li><strong><em>Zbernice typu SINGLE-MASTER</em></strong> - v systéme sa nachádza iba jeden prvok {<em>zariadenie</em>), ktorý môže pracovať ako <em>nadriadený (MASTER),</em> t.j. môže riadiť zbernicu (v prípade počítačovej zbernice typu SINGLE-MASTER je nadriadeným procesor; pamäť a V/V zariadenia sú <em>podriadenými</em>).</li><li><strong><em>Zbernice typu MULTI-MASTER</em></strong> - na zbernicu je pripojených viacero zariadení, z ktorých každé môže riadiť zbernicu. V danom okamihu je však zbernica riadená iba jedným zariadením. Pri zbernici typu MULTI-MASTER je potrebné riešiť problém <em>prideľovania zbernice</em> pri viacerých súčasných požiadavkách.</li></ul><p><strong>Podľa synchronizácie prenosu:</strong></p><ul><li><strong><em>Synchrónne zbernice</em></strong> - prenos je synchronizovaný spoločným hodinovým signálom.</li><li><strong><em>Asynchrónne zbernice</em></strong> - prenos je synchronizovaný odpoveďou podriadeného zariadenia.</li></ul><p>Synchrónne zbernice sú rýchlejšie v dôsledku prísnejších časových pravidiel a používajú sa na spojenie staníc s rovnakou prenosovou rýchlosťou. Asynchrónne zbernice sú pomalšie, pretože sa čaká na potvrdenie prenosu každého údaja. Sú však vhodné na spojenie zariadení s rôznou prenosovou rýchlosťou.</p><p><strong>Podľa tvaru prenášaných údajov:</strong></p><ul><li><strong><em>Paralelné zbernice</em></strong> - v jednom cykle zbernice sa naraz prenáša viacbitové slovo (obyčajne slabika, prípadne <em>16, 32, 64,</em> ... bitov).</li><li><strong><em>Sériové zbernice</em></strong> - údaje sa prenášajú v sériovom tvare, t.j. bit po bite.</li></ul><p><strong>Podľa časového multiplexu:</strong></p><ul><li><strong><em>Multiplexované zbernice</em></strong> - význam informácie, prenášanej po zbernici, sa mení s časom - v jednom časovom okamihu prenáša zbernica (alebo iba jej časť) jeden typ informácie (napr. <em>adresu</em>), v inom okamihu sa prenáša iný typ informácie (napr. <em>údaje</em>). V prípade takejto zbernice musia byť k dispozícii signály, ktoré <em>rozlišujú,</em> ktorý typ informácie sa po zbernici (časti zbernice) práve prenáša. Obyčajne sa multiplexuje adresová/údajová sekcia zbernice.</li><li><strong><em>Nemultiplexované zbernice</em></strong> - význam signálov, prenášaných po zbernici, sa s časom nemení.</li></ul><h4>4.1.1.2 Štruktúra typickej počítačovej zbernice</h4><p>Často používaným typom súčasných počítačových zberníc je <em>paralelná asynchrónna zbernica.</em> Skladá sa z <em>adresovej, údajovej</em> a <em>riadiacej</em> sekcie.</p><p>Po <strong><em>adresovej sekcii</em></strong> (tiež sa nazýva <em>adresová zbernica</em>) sa prenášajú <em>adresy,</em> ktoré sú generované nadriadeným prvkom zbernice, t.j. procesorom (alebo <em>riadiacim obvodom DMA,</em> pozri časť 4.4.5). Adresa identifikuje bunku v hlavnej pamäti (resp. V/V zariadenie), s ktorou (ktorým) sa bude pracovať.</p><p>Po <em><strong>údajovej sekcii</strong> (údajovej zbernici)</em> sa prenášajú <em>inštrukcie</em> (z pamäte do procesora) a <em>údaje</em> (medzi procesorom a pamäťou alebo V/V zariadením, prípadne medzi pamäťou a V/V zariadením, pozri časť 4.4.5).</p><p><em>Signály <strong>riadiacej sekcie</strong> (riadiacej zbernice)</em> sa skladajú z <em>povelov,</em> generovaných nadriadeným zbernice (napr. signál <em>čítania</em> alebo <em>zápisu</em>) a zo <em>žiadostí,</em> ktorými sa podriadení obracajú na nadriadeného (napr. žiadosť o predĺženie <em>cyklu čítania</em> alebo <em>zápisu, žiadosť o prerušenie</em> atď.).</p><p><strong><em>Prenosová rýchlosť zbernice</em></strong> udáva množstvo údajov, ktoré je možné preniesť po zbernici za jednotku času. Obyčajne sa udáva v <em>MB.s<sup>-1</sup>.</em></p><p>V jednom <strong><em>cykle zbernice</em></strong> sa vykoná prenos jediného údaja po zbernici (napr. ak je šírka údajovej zbernice <em>8 bitov,</em> v jednom cykle zbernice sa prenesie <em>jedna slabika</em>).</p><p><strong><em>Pracovná frekvencia zbernice</em></strong> (v <em>Hz</em>) je prevrátená hodnota doby trvania jedného cyklu zbernice (v <em>s</em>).</p><p>Pod <strong><em>signálovým sledom</em></strong> rozumieme časové priebehy signálov zbernice, ktoré je potrebné dodržať, aby sa korektne uskutočnil cyklus zbernice. V časti 4.3 a 4.4 uvedieme konkrétne signálové sledy pri prenose údajov po zbernici pri práci s pamäťou resp. V/V zariadením.</p><p><strong>Príklad:</strong><br />Pracovná frekvencia zbernice je <em>10 MHz</em> a šírka jej údajovej sekcie je <em>32 bitov.</em> Aká je prenosová rýchlosť zbernice?<br />Doba trvania jedného cyklu zbernice je <em>1/(10*10<sup>6</sup> Hz) = 0,0000001 s = 0,1 µs.</em><br /><em>32 bitov</em> sú <em>4 bajty,</em> takže prenosová rýchlosť je <em>4 bajty</em> za <em>0,1 µs.</em> V prepočte to predstavuje <em>40 MB.s<sup>-1</sup>.</em></p><h2>4.2 Základná koncepcia procesora</h2><p><strong><em>Procesor</em></strong> je jedna zo základných častí počítača. Jeho základná funkcia je <em>interpretovať inštrukcie programu,</em> ktorý je uložený v hlavnej pamäti. Pri tejto činnosti sa jednotlivé inštrukcie vyberajú z hlavnej pamäte, vykonávajú sa požadované operácie s operandmi, špecifikovanými v inštrukciách a uskutočňujú sa príslušné prenosy informácií medzi jednotlivými časťami číslicového počítača.</p><p><em>Podľa druhu vykonávanej funkcie</em> rozlišujeme <em>univerzálne</em> procesory a <em>problémovo orientované</em> procesory.</p><p><strong>Univerzálne procesory</strong> <strong><em>Univerzálne procesory</em></strong> realizujú hlavné číselné a nečíselné operácie a zabezpečujú riadenie ostatných častí počítača na základe programu, uloženého v pamäti počítača. Tieto procesory majú vo všeobecnosti inštrukčný súbor, ktorý je z hľadiska spracovania informácie úplný, a preto sa môžu použiť na riešenie úloh ľubovoľného typu. Samozrejme, úlohy istého typu riešia efektívnejšie, úlohy iného typu menej efektívne.</p><p><strong>Problémovo orientované procesory</strong> <strong><em>Problémovo orientované procesory</em></strong> vykonávajú v počítači <em>špecializované funkcie,</em> pričom sa používajú problémovo orientované programové prostriedky. Sú určené na riešenie úloh <em>istého typu.</em> Príkladom takýchto procesorov je <em>vstupno/výstupný procesor, numerický</em> (aritmetický) <em>koprocesor, grafický procesor, bitový procesor</em> atď.</p><p>V ďalšom sa budeme zaoberať univerzálnymi procesormi a pod slovom <em>procesor</em> budeme rozumieť <em>univerzálny procesor.</em></p><strong>Hlavné časti procesora:</strong> Procesor sa skladá z dvoch hlavných častí - <em>operačnej</em> časti a <em>riadiacej</em> časti. <ul><li><em><strong>Operačná časť</strong> vykonáva operácie s operandmi</em> na základe <em>povelov</em> z riadiacej časti. O výsledkoch operácií informuje riadiacu časť prostredníctvom <em>príznakov.</em></li><li><em><strong>Riadiaca časť</strong> vyberá inštrukcie z pamäte, dekóduje</em> ich a zabezpečuje ich <em>vykonanie.</em> Riadi <em>spoluprácu procesora s okolím</em> (komunikácia s pamäťou a vstupno/výstupnými zariadeniami, <em>obsluha prerušenia</em> atď.).</li></ul><h3>4.2.1 Operačná časť procesora</h3><p><strong><em>Operačná časť procesora</em></strong> sa skladá z <em>aritmeticko-logickej jednotky, registrov</em> a <em>komunikačných obvodov.</em></p><ul><li><em><strong>Aritmeticko-logická jednotka</strong> (ALU - Arithmetic and Logic Unit)</em> je určená na bezprostredné vykonanie požadovaných aritmetických, logických a iných operácií s operandmi.</li><li><em><strong>Registre</strong> (zápisníková pamäť)</em> slúžia na prechodné uloženie operandov, vstupujúcich do týchto operáciií, ako aj na uloženie výsledku.</li><li><strong><em>Komunikačné obvody</em></strong> umožňujú vykonávanie <em>medziregistrových prenosov.</em></li></ul><h4>4.2.1.1 Aritmeticko-logická jednotka</h4><p>Základnou úlohou <em>ALU</em> je vykonanie elementárnych <em>aritmetických</em> a <em>logických</em> operácií, na základe ktorých je možné realizovať ľubovoľné, algoritmicky definované spracovanie <em>číselných</em> a <em>nečíselných</em> údajov. Okrem týchto elementárnych operácií <em>ALU</em> realizuje aj ďalšie typické operácie (<em>posuvy, predikáty,</em> atd&#39;.).</p><p><strong>Realizácia základných aritmetických operácií</strong><br />Základ <em>ALU</em> na úrovni logických obvodov na realizáciu základných aritmetických operácií predstavuje obyčajne <em>paralelná dvojková sčítačka.</em> Na jej vstupy sú pripojené <em>n-bitové</em> operandy, sčítačka na výstupe poskytuje <em>n-bitový výsledok</em> a <em>výsledný prenos.</em><br />Majme dva <em>n-bitové</em> operandy <em>A, B,</em> zapísané v tvare:<br /><br />A = A<sub>n-1</sub>A<sub>n-2</sub>...A<sub>0</sub><br />B = B<sub>n-1</sub>B<sub>n-2</sub>...B<sub>0</sub><br /><br />Na základe skôr uvedených pravidiel sčítania jednobitových čísel pre <em>i-ty</em> rád platí:<br />S<sub>i</sub> = A<sub>i</sub>⊕B<sub>i</sub>⊕C<sub>i</sub><br />C<sub>i+1</sub> = A<sub>i</sub>.B<sub>i</sub> + A<sub>i</sub>.C<sub>i</sub> + B<sub>i</sub>.C<sub>i</sub><br /><br />kde:<br />A<sub>i</sub>, B<sub>i</sub> sú <em>i-te</em> rády čísel <em>A</em> resp. <em>B,</em><br />C<sub>i</sub> - prenos z predchádzajúceho rádu,<br />S<sub>i</sub> - súčet v <em>i-tom</em> ráde,<br />C<sub>i+1</sub> - prenos generovaný do nasledujúceho rádu.</p><p>Na nasledujúcom obrázku je nakreslená bloková a logická schéma <em>i-teho</em> rádu paralelnej dvojkovej sčítačky.<br /></p><div style="text-align: center"><img src="../files/obrazky/obr_22.png" border="0" alt="22" width="663" height="452" /></div><br /><p>&#160;</p><p align="center">OBR. 4.2. <em>i-ty</em> rád paralelnej dvojkovej sčítačky</p><p><strong><em>n-bitová</em></strong> sčítačka sa vytvorí jednoducho zreťazením požadovaného počtu uvedených buniek. Je zrejmé, že pri uvedenej realizácii paralelnej sčítačky je nevyhnutné čakať na výsledok, ktorý dostaneme až po prešírení prenosu z najnižšieho do najvyššieho rádu. Na elimináciu tejto skutočnosti boli vytvorené <em>sčítačky so zrýchleným prenosom.</em> n-bitovú paralelnú sčítačku je tiež možné jednoducho realizovať pomocou pamäte typu <em>ROM.</em></p><p>Okrem paralelných dvojkových sčítačiek existujú aj <em>sériové sčítačky,</em> kde sa sčítanie realizuje postupne, spočítavaním zodpovedajúcich bitov operandov a hodnoty prenosu z predchádzajúceho rádu. Spočítavame začína od najnižšieho rádu, kedy je vstupný prenos nulový. V prípade sériovej sčítačky je nutné uchovať v každom kroku hodnotu výsledku a hodnotu prenosu, ktorá vstúpi do operácie v ďalšom kroku.</p><p>Ukázali sme si, že dvojkovú sčítačku je okrem sčítania možné použiť aj na odčítanie (pozri časť 2.3.2.5). Okrem toho je aj základnou časťou zložitejších obvodov na realizáciu násobenia a delenia.</p><p><strong>Realizácia ďalších typických operácií</strong><br />Ukážeme si, akým spôsobom sa realizujú <em>logické operácie, posuvy</em> a <em>predikáty.</em></p><p><strong>Logické operácie</strong><br />Na obr. 4.3 je nakreslená funkčná jednotka na realizáciu niektorej vektorovej logickej funkcie <em>f</em> nad dvoma <em>n-bitovými</em> vektormi <em>X</em> a <em>Y.</em></p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/obr_23.png" border="0" alt="23" width="645" height="310" /></div><br /><p>&#160;</p><p align="center">OBR. 4.3. Funkčná jednotka na realizáciu vektorovej logickej funkcie</p><p>Funkčná jednotka môže byť vyhotovená aj ako <em>viacfunkčná,</em> t.j. na základe nastavených <em>riadiacich premenných</em> sa realizuje vybraná funkcia. Na obr. 4.4 je nakreslená logická schéma <em>dvojfunkčnej</em> jednotky na realizáciu funkcií <em>AND</em> a <em>OR.</em></p><p><em>MUX</em> označuje multiplexor <em>2 na 1.</em> Riadiace vstupy všetkých multiplexorov sú navzájom prepojené a sú ovládané premennou <em>FUNKCIA.</em></p><div style="text-align: center"><img src="../files/obrazky/obr_24.png" border="0" alt="24" width="616" height="256" /></div><br /><p>&#160;</p><p align="center">OBR. 4.4. Funkčná jednotka pre realizáciu vektorových funkcií AND a OR</p><p>Ak <em>FUNKCIA = log.O,</em> funkčná jednotka bude realizovať nad vektormi <em>X</em> a <em>Y</em> logickú funkciu <em>AND.</em> Ak <em>FUNKCIA = log.1,</em> bude realizovaná funkcia <em>OR.</em></p><p><strong>Posuvy</strong></p><p>Pri vykonávaní niektorých aritmetických funkcií, ale aj pri iných funkciách sa vyžaduje realizovať <em>posuvy boolovských vektorov.</em> Sú to napr. operácie násobenia alebo delenia, násobenie resp. delenie mocninami 2<sup>n</sup> atď.</p><p>Posuvy sa realizujú <em>posúvacím obvodom.</em> Je to kombinačný logický obvod, ktorý realizuje jeden alebo viac typov posuvov. Má <em>n</em> vstupov pre operand a <em>n</em> výstupov pre výsledok <em>(n&gt;l).</em></p><p>Najčastejšie sa používajú tieto <em>pravé</em> a <em>ľavé posuvy</em> o <em>n</em> miest: <em>logický posuv, kruhový (cyklický) posuv</em> a <em>aritmetický posuv.</em> Kruhový posuv sa často nazýva <em>rotácia.</em><br />Na obr. 4.5 sú nakreslené posúvacie obvody na realizáciu logického a kruhového posuvu o jedno miesto vpravo.</p><p align="center"><img src="../files/obrazky/obr_25.png" border="0" alt="25" width="425" height="226" /> <br /></p><p align="center">OBR. 4.5. Posúvacie obvody na realizáciu logického a kruhového posuvu o jedno miesto vpravo </p><p>Aj posúvacie obvody sa často vyhotovujú ako viacfunkčné. Potom okrem vstupov pre operand a výstupov pre výsledok obsahujú aj<em>riadiace vstupy,</em> na základe ktorých sa realizuje vybraný druh posuvu.<br />Na obr. 4.6 je bloková schéma viacfunkčného posúvacieho obvodu.</p><div style="text-align: center"><img src="../files/obrazky/obr_26.png" border="0" alt="26" width="490" height="302" /></div><p align="center">OBR. 4.6. Viacŕunkčný posúvací obvod</p><p><em>POS</em> označuje posúvacie obvody pre jednotlivé typy posuvov.</p><p><em>MUX</em> označuje <em>n-bitový</em> multiplexor <em>k na 1,</em> takže na výstup multiplexora je vždy prenášaný iba výstup z jedného posúvacieho obvodu pre vybraný&#39; typ posuvu. Typ posuvu je vybraný vektorovou riadiacou premennou <em>VYBER.</em><br />Muitiplexor by nebolo potrebné použiť v prípade, ak by sa posúvacie obvody realizovali ako obvody s trojstavovým výstupom.</p><p><strong>Predikáty</strong></p><p><em><strong>Predikáty</strong> (príznaky)</em> definované nad číslicovými premennými rozličných údajových typov sú <em>dvojhodnotové funkcie.</em> Najčastejšie sa implementujú kombinačnými logickými obvodmi. Výstupná boolovská premenná takéhoto obvodu je potom priamym nositeľom hodnoty predikátu. Predikáty sa realizujú nad <em>jedným operandom</em> (napr. <em>rovný nule, väčší ako nula, menší ako nula</em> atď.), ako aj nad <em>dvoma</em> príp. <em>viacerými operandmi (rovnajú sa, prvý je väčší ako druhý atď.).</em></p><p>Na obr. 4.7 je logická schéma obvodu, ktorý realizuje predikát P(X, Y) = 1 &lt;=&gt; X = Y, kde X a Y sú boolovské vektory.</p><div style="text-align: center"><img src="../files/obrazky/obr_27.png" border="0" alt="27" width="298" height="280" /></div><p align="center">OBR. 4.7. Predikačný obvod</p><p>Predikáty sa v procesore pre ďalšie spracovanie (vyhodnotenie) uchovávajú v špeciálnom registri, ktorý sa nazýva <em>príznakový (FLAG) register.</em></p><h4>4.2.1.2 Komunikačné obvody</h4><p><em><strong>Komunikačné obvody</strong> prepájajú</em> jednotlivé štruktúrne prvky operačnej časti a umožňujú realizovať <em>medziregistrové prenosy.</em> V zásade sa používajú dva spôsoby realizácie prepojovacích obvodov - prvý je použitie <em>multiplexorov a demultiplexorov,</em> druhý spôsob je použitie <em>zbernice.</em></p><p><strong>Multiplexory a demultiplexory</strong></p><p>Pomocou multiplexorov a demultiplexorov možno v štruktúre operačnej časti vytvoriť <em>ľubovoľné riadené údajové cesty.</em></p><p>Na obr. 4.8 je príklad prepojenia registrov s aritmeticko-logickou jednotkou pomocou multiplexorov a demultiplexorov. Na vstup <em>X ALU</em> možno pripojiť register <em>AX</em> alebo <em>BX</em>, na vstup <em>Y</em> register <em>CX</em> alebo <em>DX.</em> Údaj z výstupu <em>ALU</em> sa môže zapísať do ľubovoľného registra. Registre majú riadený zápis (riadiace vstupy <em>WRiX</em>), takže rozvetvenie sa realizuje <em>implicitne</em> pomocou zapisovacej logiky registrov (<em>skryté demultiplexovanie,</em> pozri časť 3.7.3).</p><p><em>DI</em> predstavuje vstupný údajový kanál, <em>DO</em> výstupný údajový kanál.<br /><em>F1</em> a <em>F2</em> sú riadiace vstupy <em>ALU,</em> ktoré nastavujú príslušnú požadovanú funkciu.<br /><em>N, Z, V</em> a <em>C</em> sú predikáty, ktoré informujú o výsledkoch vykonania oprácie v <em>ALU (Negatíve - príznak záporného výsledku, Zero - nulový výsledok, oVerflow -pretečenie, Carry - prenos z najvyššieho rádu).</em></p><p><strong>Zbernica</strong></p><p>Zbernica je často používaný systém prepojenia v operačných častiach procesorov. Prepája navzájom všetky štruktúrne prvky, pričom v danom čase je možné prenášať údaj z jedného východiskového prvku do jedného (alebo niekoľkých) cieľových prvkov. Aby nebolo potrebné pripájať výstupy jednotlivých prvkov na zbernicu cez multiplexor, obyčajne sa výstupy pripájajú na zbernicu cez <em>trojstavové hradlá</em> alebo sa priamo použijú <em>prvky s trojstavovým výstupom.</em></p><div style="text-align: center"><img src="../files/obrazky/obr_28.png" border="0" alt="28" width="661" height="604" /></div><p align="center">OBR. 4.8. Prepojenie registrov s ALU prostredníctvom multiplexorov a demultiplexorov</p><p>Na obr. 4.9 je príklad prepojenia registrov s aritmeticko-logickou jednotkou pomocou zbernice. Použité sú síce ďalšie dva pomocné registre <em>TMP1</em> a <em>TMP2,</em> ale vzhľadom na štruktúru na obr. 28 je prepojenie jednoduchšie a univerzálnejšie (ako zdroj operandov môžu slúžiť, ľubovoľné registre, jednoduchý presun informácií medzi registrami). Registre <em>AX</em> až <em>DX</em> majú trojstavové výstupy, ktoré sú ovládané signálmi <em>RDiX. ALU</em> má takisto trojstavový výstup, ktorý sa pripojí na zbernicu iba vtedy, ak je požadované vykonanie nejakej operácie (vtedy bude signál <em>RDALU</em> aktívny). Interná údajová zbernica je obojsmerná, vstupný, resp. výstupný údajový kanál je možné jednoducho realizovať prostredníctvom trojstavových hradiel (nie sú nakreslené, môžu byť spoločné aj pre riadiacu časť).</p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/obr_29.png" border="0" alt="29" width="709" height="402" /></div><br /><p>&#160;</p><p align="center">OBR. 4.9. Prepojenie registrov s ALU prostredníctvom zbernice</p><h3>4.2.2 Riadiaca časť procesora</h3><p><strong><em>Riadiaca časť procesora</em></strong> uskutočňuje <em>výber a dekódovanie inštrukcií</em> a zabezpečuje ich <em>vykonanie.</em> Okrem toho <em>riadi spoluprácu procesora s okolím.</em></p><h4>4.2.2.1 Formát inštrukcie</h4><p><strong><em>Inštrukcia</em></strong> je príkaz pre procesor, ktorý mu určuje, akú činnosť má vykonať. Vo všeobecnosti sa inštrukcia skladá z viacerých polí (obr. 4.10).</p><div style="text-align: center"><img src="../files/obrazky/obr_30.png" border="0" alt="30" width="380" height="46" /></div><p align="center">OBR. 4.10. Všeobecný formát inštrukcie</p><p>Pole <em>OC</em> je tzv. <em>operačný kód. <strong>Operačný kód</strong></em> špecifikuje <em>operáciu,</em> ktorá sa má vykonať. Pole <em>ADDR</em> obsahuje <strong><em>adresu operandu</em></strong> (operandov) pre príslušnú operáciu. Obyčajne sa používajú <em>jedno-, dvoj-</em> prípadne <em>trojoperandové</em> inštrukcie. Treba si uvedomiť, že nie všetky inštrukcie však potrebujú pole <em>ADDR</em> (napr. inštrukcia pre <em>povolenie prerušenia</em>). V takýchto inštrukciách by pole <em>ADDR</em> nebolo využité a tento formát by bol neefektívny. Preto sa často používa niekoľko formátov inštrukcií, ktoré majú rôznu dĺžku alebo pri inštrukciách <em>s pevnou dĺžkou</em> sa nevyužité bity poľa <em>ADDR</em> môžu použiť na <em>rozšírenie operačného kódu.</em></p><p><strong>Príklad:</strong><br />Predpokladajme, že máme počítač so <em>16</em> registrami, ktorý môže adresovať <em>64 kB</em> operačnej pamäte. Použijeme pevný formát inštrukcie, každá inštrukcia bude mať dĺžku <em>24</em> bitov a bude obsahovať tieto polia:</p><p>Pole <em>OC</em> je operačný kód, pole <em>R</em> je použité pre adresovanie operandu, ktorý je v registri a pole <em>ADDR</em> pre operand, ktorý je v operačnej pamäti.</p><p>Pri takomto formáte budeme mať k dispozícii <em>16 dvojoperandových</em> inštrukcií. Prvý operand bude v registri a druhý operand v pamäti.</p><p><strong>Rozšírenie operačného kódu:</strong></p><p>Ak použijeme jednu zo <em>16</em> kombinácií poľa <em>OC</em> na indikáciu, že operačný kód je <em>rozšírený</em> aj o pole <em>R,</em> inštrukčný súbor sa bude skladať z <em>15 dvojoperandových</em> inštrukcií (prvý operand v registri a druhý v pamäti) a <em>16 jednooperandových</em> inštrukcií (operand v pamäti). Opäť môžeme jednu kombináciu poľa <em>R</em> použiť na indikáciu, že operačný kód je rozšírený aj o pole <em>ADDR</em> a tým sa nám inštrukčný súbor rozšíri na <em>15 dvojoperandových</em> inštrukcií, <em>15 jednooperandových</em> inštrukcií a <em>65536 bezoperandových</em> inštrukcií. Celá situácia je ilustrovaná na obr. 4.11.</p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/obr_31.png" border="0" alt="31" width="406" height="342" /></div><br /><p>&#160;</p><p align="center">OBR. 4.11. Rozšírenie operačného kódu inštrukcií s pevnou dĺžkou</p><h4>4.2.2.2 Typy inštrukcií</h4><p>Podľa <em>vykonávanej činnosti</em> delíme inštrukcie na <em>presunové, výpočtové (operačné), skokové</em> a <em>riadiace.</em> Inštrukcie, uvedené na ilustráciu jednotlivých typov, sú z inštrukčného súboru procesorov rodiny <em>80x86</em> a ich detailný opis možno nájsť napr. v [2].</p><ul><li><strong><em>Presunové inštrukcie</em></strong> slúžia na presun údajov medzi registrami procesora, medzi registrom a pamäťou, registrom a V/V zariadením alebo medzi pamäťovými miestami navzájom.</li></ul><p><strong>Príklad:</strong></p><pre>MOV   AX,BX
MOV   ALFA, CX
MOV   BX, BETA
IN    AL,DX
OUT   10H, AL
MOVSB</pre><ul><li><strong><em>Výpočtové (operačné) inštrukcie</em></strong> predpisujú vykonanie aritmetických, logických alebo iných operácií s operandmi.</li></ul><p><strong>Príklad:</strong></p><pre>ADD  SI, OFFSET_ARRAY
SUB  CX, 4
AND  AL, MASK
TEST AL, FLAG1
ROL  AX, CX</pre><ul><li><strong><em>Skokové inštrukcie</em></strong> slúžia na zmenu lineárneho vykonávania programu, t.j. namiesto inštrukcie, na ktorú ukazuje programové počítadlo, sa vykoná inštrukcia, adresa ktorej je špecifikovaná v práve vykonávanej inštrukcii. Skoky môžu byť <em>podmienené</em> alebo <em>nepodmienené.</em></li></ul><p>Inštrukcia pre <strong><em>podmienený skok</em></strong> testuje nejaký predikát, napr. výsledok porovnania dvoch operandov, príznak nulového výsledku, prenos do vyššieho rádu a pod. Ak je daná podmienka splnená, skok sa uskutoční. V opačnom prípade sa skok neuskutoční a pokračuje sa nasledujúcou inštrukciou.</p><p><strong>Príklad:</strong></p><pre>JAE ABOVE_OR_EQUAL
JZ  ZERO</pre><p>Inštrukcia pre <strong><em>nepodmienený skok</em></strong> sa vykoná bez ohľadu na nejaké podmienky.</p><p><strong>Príklad:</strong></p><pre>JMP  FAR PTR NEXT_SEG</pre><p>Medzi skokové inštrukcie patria aj <strong><em>inštrukcie volania podprogramu</em></strong> (sú to <em>skoky s uchovaním adresy návratu</em>). Adresa návratu sa uchová do <em>zásobníka.</em> Podprogram je ukončený <strong><em>inštrukciou návratu z podprogramu,</em></strong> ktorá zo zásobníka vyberie uchovanú adresu návratu a naplní ju do registra PC.</p><p><strong><em>Zásobník</em></strong> sa nachádza v hlavnej pamäti. Je to údajová štruktúra typu <em>LIFO (Last In First Out)</em> - posledná vložená položka je prvá vybraná. Pri práci s údajmi v zásobníku sa používa <em>implicitné zásobníkové adresovanie.</em> Pri tomto spôsobe adresovania sa adresa pre uloženie/výber údaja nachádza v špeciálnom registri, ktorý sa nazýva <em>ukazovateľ zásobníka (Stack Pointer - SP).</em> Okrem odkladania adresy návratu pri volaní podprogramu sa zásobník používa aj na uchovanie <em>stavu procesora,</em> pri <em>obsluhe prerušenia</em> a na <em>odovzdávanie parametrov.</em></p><p><strong>Príklad:</strong></p><pre>CALL  SQRT   ; inštrukcia volania podprogramu
RET          ; inštrukcia návratu z podprogramu</pre><ul><li><strong><em>Riadiace inštrukcie</em></strong> sú určené na vykonanie <em>špeciálnych</em> operácií, ktoré priamo súvisia s riadiacou alebo operačnou časťou, prípadne s reakciou na externé stimuly. Sú to napr. <em>inštrukcie na nastavenie</em> alebo <em>vynulovanie príznakov</em> v operačnej časti, <em>povolenie</em> alebo <em>zakázanie externého prerušenia, softvérové prerušenie</em> atď.</li></ul><p><strong>Príklad:</strong></p><pre><em>CLD
STC
STI
CLI
INT   21H
LMSW  AX</em></pre><h4>4.2.2.3 Spôsoby adresovania operandov</h4><p>Inštrukcie pracujú s operandmi, ktoré môžu byť adresované rôznymi spôsobmi. Treba si však uvedomiť, že pri ľubovoľnom spôsobe adresovania je výsledkom tzv. <em>fyzická adresa,</em> t.j. adresa, ktorú procesor vysiela na adresovú zbernicu. V nasledujúcej tabuľke uvedieme niekoľko najpoužívanejších spôsobov adresovania operandov, pričom ich budeme ilustrovať inštrukciami procesorov rodiny <em>80x86.</em></p><table border="1" cellpadding="5"><tbody><tr><td align="center"><strong>Adresovanie</strong></td><td align="center"><strong>V inštrukcii</strong></td><td align="center"><strong>V registri</strong></td><td align="center"><strong>V pamäti</strong></td><td align="center"><strong>Príklad</strong></td></tr><tr><td>Implicitné:<br /><em>Registrové<br />Nepriame registrové<br />Zásobníkové</em></td><td align="center"><br />Operand<br />Adresa<br />Adresa</td><td align="center"><br /><br />Operand<br />Operand</td><td align="center"><br />SCASW<br />MOVSB<br />POPF</td></tr><tr><td>Bezprostredné</td><td align="center">Operand</td><td align="center">MOV CX, 10H</td></tr><tr><td>Registrové</td><td align="center">Register</td><td align="center">Operand</td><td align="center">MOV BX, DI</td></tr><tr><td>Priame</td><td align="center">Adresa</td><td align="center">Operand</td><td align="center">MOV ALFA, DX</td></tr><tr><td>Nepriame</td><td align="center">Adresa1</td><td align="center">Adresa2</td><td align="center">JMP WORD PTR DST</td></tr><tr><td>Nepriame registrové</td><td align="center">Register</td><td align="center">Adresa</td><td align="center">Operand</td><td align="center">JMP WORD PTR [BX]</td></tr><tr><td>Indexové</td><td align="center">Indexový reg.<br />*Posunutie</td><td align="center">Index</td><td align="center">Operand</td><td align="center">MOV QQQ[DI], AX</td></tr><tr><td>Bázovo-indexové</td><td align="center">Bázový reg.<br />Indexový reg.<br />*Posunutie</td><td align="center">Bázová adresa<br />Index</td><td align="center">Operand</td><td align="center">MOV AX, QQ[BX][SI]</td></tr></tbody></table><p>*Posunutie môže, ale nemusí byť. V príklade je uvedené.</p><h4>4.2.2.4 Riadiaca časť s pevnou logikou</h4><p><strong><em>Riadiaca časť s pevnou logikou</em></strong> je implementovaná ako <em>sekvenčný obvod.</em> Jeho funkcia je <em>napevno daná zapojením.</em></p><p><strong><em>Vstupný vektor</em></strong> tohto sekvenčného obvodu je tvorený <em>inštrukciami, signálmi z externého okolia</em> (napr. žiadosť o prerušenie, signál pripravenosti periférie atď.) a <em>príznakmi z operačnej časti.</em></p><p><strong><em>Výstupný vektor</em></strong> sa skladá z <em>povelov pre operačnú časť</em> (napr. signál zápisu do registra, nastavenie funkcie aritmeticko-logickej jednotky atď.) <em>a pre externé okolie</em> (napr. signál čítania z pamäte, zápisu do výstupného zariadenia, potvrdenia prerušenia atď.).</p><p>Iba málo riadiacich jednotiek je implementovaných ako asynchrónne sekvenčné obvody, pričom ide obyčajne iba o malé riadiace jednotky. Dôvody spočívajú najmä pri obťažnom odstraňovaní dôsledkov asynchrónne prebiehajúcich udalostí (zmien hodnôt premenných) v logických obvodoch, ktoré môžu vyvolať nesprávnu funkciu systému. Oveľa viac sa používajú riadiace jednotky, implementované ako synchrónne sekvenčné obvody.</p><h4>4.2.2.5 Mikroprogramová riadiaca jednotka</h4><p><strong><em>Mikroprogramové riadiace jednotky</em></strong> sú synchrónne systémy, v ktorých je inštrukcia realizovaná <em>vykonaním mikroprogramu.</em></p><p><strong><em>Mikroprogram</em></strong> je postupnosť <em>mikroinštrukcií,</em> ktoré sú uložené v <em>pamäti mikroinštrukcií.</em> Mikroprogramovú riadiacu jednotku môžeme teda charakterizovať ako špecializovaný procesor, ktorý priamo interpretuje mikroprogramy, uložené v svojej pamäti mikroprogramov a vykonáva ich na danej operačnej časti. Je zrejmé, že zmenou obsahu pamäte mikroinštrukcií je možné dosiahnuť zmenu inštrukčného súboru procesora. Takýmto spôsobom je potom možné na jednom procesore vykonávať programy pre iný typ procesora. Vtedy hovoríme o <strong><em>mikroprogramovej emulácii.</em></strong></p><p>Základná štruktúra mikroprogramovej riadiacej jednotky je na obr. 4.12.</p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/obr_32.png" border="0" alt="32" width="368" height="211" /></div><br /><p>&#160;</p><div align="center">OBR. 4.12. Koncepcia mikroprogramovej riadiacej jednotky</div><p>V <em><strong>pamäti mikroprogramov</strong> (MM) sa nachádzajú mikroprogramy.</em> Časť pamäte mikroprogramov môže byť realizovaná ako <em>prepisovateľná,</em> čo potom umožňuje dynamickú zmenu (doplnenie) inštrukčného súboru procesora.</p><p>Úlohou <em><strong>sekvenčnej jednotky</strong> (SEQ) je vypracovať adresu A</em> nasledujúcej mikroinštrukcie. Vstupný vektor <em>X</em> predstavujú <em>príznaky z operačnej časti</em> a <em>vonkajšie riadiace vstupy,</em> vektor <em>I</em> je informácia z <em>interných polí</em> mikroinštrukcie a výstupný vektor <em>Y</em> je <em>riadiacim vektorom pre operačnú časť</em> a sú z neho odvodené tiež <em>vonkajšie riadiace výstupy.</em></p><p>Diskrétny čas je definovaný zmenami synchronizačnej premennej (hodinový signál) <em>CLK.</em></p><p><strong>Činnosť mikroprogramovej riadiacej jednotky</strong></p><p>Činnosť mikroprogramovej riadiacej jednotky je <em>cyklická.</em> V každom <em>mikrocykle</em> vyšle sekvenčná jednotka na výstupe <em>A</em> adresu mikroinštrukcie, mikroinštrukcia sa načíta, vyšle sa výstupný vektor <em>Y,</em> sekvenčná jednotka otestuje hodnoty vstupov <em>X</em> a <em>I</em> a vytvorí novú adresu, ktorá sa použije v nasledujúcom mikrocykle.</p><p><strong>Príklad:</strong><br />Máme k dispozícii operačnú časť z obr. 4.9. Nech <em>ALU</em> realizuje operácie +, -, AND a OR, ktoré sú zakódované nasledovným spôsobom:</p><pre>F1    F2    Operácia
--------------------
0     0     X + Y
0     1     X - Y
1     0     X AND Y
1     1     X OR Y</pre><p>Uvažujme teraz o spôsobe implementácie nasledovných inštrukcií v mikroprogramovej riadiacej jednotke:</p><table border="0"><tbody><tr><td><em>MOV</em></td><td><em>AX, ADDR</em></td><td>- načítanie údaja z pamäte z adresy <em>ADDR</em> do registra <em>AX</em></td></tr><tr><td><em>MOV</em></td><td><em>ADDR, AX</em></td><td>- presun obsahu registra <em>AX</em> do pamäte na adresu <em>ADDR</em></td></tr><tr><td><em>JMP</em></td><td><em>ADDR</em></td><td>- nepodmienený skok na adresu <em>ADDR</em></td></tr><tr><td><em>JZ</em></td><td><em>ADDR</em></td><td>- ak príznak <em>Z = 1,</em> skok na adresu <em>ADDR</em><br />- ak príznak <em>Z = 0,</em> pokračuje sa nasledujúcou inštrukciou</td></tr><tr><td><em>JNC</em></td><td><em>ADDR</em></td><td>- ak príznak <em>C = 0,</em> skok na adresu <em>ADDR</em><br />- ak príznak <em>C = 1,</em> pokračuje sa nasledujúcou inštrukciou</td></tr><tr><td><em>IN</em></td><td><em>AX, ADDR</em></td><td>- načítanie údaja zo vstupného zariadenia z adresou <em>ADDR</em></td></tr><tr><td><em>OUT</em></td><td><em>ADDR, AX</em></td><td>- zápis obsahu registra <em>AX</em> do výstupného zariadenia s adresou <em>ADDR</em></td></tr><tr><td><em>ADD</em></td><td><em>AX, BX</em></td><td>- spočítanie obsahu registrov <em>AX</em> a <em>BX,</em> výsledok sa uloží do <em>AX</em></td></tr></tbody></table><p>Na zakódovanie inštrukcií použijeme kvôli jednoduchosti formát inštrukcie z obr. 4.10.</p><p>Podľa koncepcie z obr. 4.12 teraz navrhneme detailnejšiu štruktúru mikroprogramovej riadiacej jednotky.</p><div style="text-align: center"><img src="../files/obrazky/obr_33.png" border="0" alt="33" width="699" height="738" /></div><p align="center">OBR. 4.13. Jednoduchá mikroprogramová riadiaca jednotka</p><p><em><strong>Oddeľovač údajovej zbernice</strong> (MBR)</em> oddeľuje <em>vnútornú údajovú zbernicu</em> od okolia. Ak <em>WR2 = 1,</em> je prepnutý v smere <em>IDB → EDB,</em> ak <em>RD2 = 1,</em> v smere <em>EDB → IDB.</em><br /><em><strong>Vnútorná údajová zbernica</strong> (IDB)</em> slúži na prenos údajov medzi procesorom a vonkajším okolím (pamäť, resp. V/V zariadenia), medzi registrami v operačnej časti, prípadne na prenos inštrukcií z pamäte do riadiacej časti. Výstupy, ktoré sú na ňu pripojené, musia byť preto trojstavové.<br /><em><strong>Register adresy</strong> (MAR)</em> obsahuje adresu bunky v hlavnej pamäti alebo adresu V/V zariadenia, s ktorým sa v danom cykle zbernice pracuje. Súčasne oddeľuje <em>internú adresovú zbernicu</em> od vonkajšieho okolia.<br />Na <strong><em>internú adresovú zbernicu</em></strong> sa vysiela buď adresa inštrukcie, ktorá sa bude v nasledujúcom cykle vyberať z pamäte alebo adresová časť práve vykonávanej inštrukcie (pole <em>ADDR</em> z registra <em>IR</em>).<br /><em><strong>Register inštrukcie</strong> (IR)</em> obsahuje práve vykonávanú inštrukciu. Všimneme si, že na základe operačného kódu (pole <em>OC</em>) sa odštartuje príslušný mikroprogram.<br /><em><strong>Programové počítadlo</strong> (PC)</em> obsahuje adresu nasledujúcej inštrukcie.<br /><em><strong>Mikroprogramové počítadlo</strong> (MPC</em>) obsahuje adresu nasledujúcej mikroinštrukcie. <em><strong>Register mikroinštrukcie</strong> (MIR)</em> obsahuje práve vykonávanú mikroinštrukciu.<br />Funkcia <em>pamäte mikroprogramov (MM)</em> a <em>sekvenčnej jednotky (SEQ)</em> už bola opísaná.</p><p><strong>Formát mikroinštrukcie</strong></p><p>Mikroinštrukcia sa skladá z viacerých polí:</p><p>Pole <em>CODE</em> určuje typ mikroinštrukcie, je to vlastne pole <em>I</em> z obr. 4.12. Pole <em>COND</em> vyberá jeden predikát z operačnej časti (príznak <em>N, Z, V</em> alebo <em>C</em>).<br />Pole <em>MADDR</em> obsahuje adresu mikroinštrukcie, ktorá sa použije ako cieľ pri <em>skokovej mikroinštrukcii.</em><br />Pole <em>CMDS</em> obsahuje povely pre riadiacu časť <em>(MUX1, MUX2, WR1, WR2, WR3, WR4, RD2),</em> pre operačnú časť <em>(WRAX, RDAX, WRBX, RDBX, WT1, WT2, Fl, F2, RDALU)</em> a externé povely <em>(MEMR#, MEMW#, IOR#, IOW#).</em> Význam povelov pre riadiacu a operačnú časť je zrejmý z obr. 4.9 resp. z obr. 33. Externé povely majú tento význam:</p><table border="0"><tbody><tr><td><em>MEMR#</em></td><td>- signál čítania z pamäte,</td></tr><tr><td><em>MEMW#</em></td><td>- signál zápisu do pamäte,</td></tr><tr><td><em>IOR#</em></td><td>- signál čítania zo vstupného zariadenia,</td></tr><tr><td><em>IOW#</em></td><td>- signál zápisu do výstupného zariadenia.</td></tr></tbody></table><p>(# označuje negáciu, t.j. príslušný signál má aktívnu úroveň <em>log.0</em>).</p><p><strong>Určenie adresy nasledujúcej mikroinštrukcie</strong></p><p>V nasledujúcej tabuľke si ukážeme, ako sekvenčná jednotka <em>SEQ</em> na základe poľa <em>CODE</em> a príznaku <em>FLAG</em> určuje adresu nasledujúcej mikroinštrukcie:</p><p>Tabuľka 2. Určenie adresy nasledujúcej mikroinštrukcie</p><p>Tabuľka 3. Obsah pamäte mikroprogramov</p><table border="1" cellpadding="5"><tbody><tr align="center"><td><strong><em>CODE</em></strong></td><td><strong>Adresa nasledujúcej mikroinštrukcie</strong></td><td><strong><em>MUX3</em></strong></td><td><strong>Poznámka</strong></td></tr><tr align="center"><td><em>0</em></td><td>obsah poľa <em>OC</em></td><td><em>0</em></td><td>dekódovanie inštrukcie</td></tr><tr align="center"><td><em>1</em></td><td>obsah poľa <em>MADDR</em></td><td><em>1</em></td><td>skoková mikroinštrukcia</td></tr><tr align="center"><td><em>2</em></td><td><em>+ 1</em></td><td><em>2</em></td><td>obyčajná mikroinštrukcia</td></tr><tr align="center"><td><em>3</em></td><td>ak <em>FLAG = 0</em><br />ak <em>FLAG = 1</em></td><td><em>1</em><br /><em>2</em></td><td>podmienená mikroinštrukcia</td></tr></tbody></table><p><strong>Obsah pamäte mikroprogramov</strong></p><p>V tabuľke 3 je uvedený obsah pamäte mikroprogramov na realizáciu požadovaných inštrukcií. V stĺpci &quot;Poznámka&quot; je vyznačený začiatok mikroprogramu pre realizáciu každej inštrukcie (napr. mikroprogram inštrukcie <em>MOV ADDR, AX</em> začína na adrese 5).<br />Znak &quot;-&quot; v poliach <em>COND</em> a <em>MADDR</em> mikroinštrukcie znamená, že príslušné pole v mikroinštrukcii nie je využité a teda na jeho obsahu nezáleží. V poli <em>CMDS</em> reprezentuje situáciu, že žiaden povel nie je v aktívnej úrovni.</p><table border="1" cellpadding="5"><tbody><tr align="center"><td><strong>Adresa v MM</strong></td><td><strong><em>CODE</em></strong></td><td><strong><em>COND</em></strong></td><td><strong><em>CMDS</em></strong></td><td><strong><em>MADDR</em></strong></td><td><strong>Poznámka</strong></td></tr><tr align="center"><td><em>0</em></td><td><em>2</em></td><td><em>-</em></td><td><em>MUX1 = 0, WR1 = 1,<br />MEMR# = 0</em></td><td><em>-</em></td><td>Výber inštrukcie z pamäte</td></tr><tr align="center"><td><em>1</em></td><td><em>2</em></td><td><em>-</em></td><td><em>MEMR# = 0,<br />RD2 = 1, WR3 = 1,<br />MUX2 = 0, WR4 = 1</em></td><td><em>-</em></td><td><br /><br />:= + 1</td></tr><tr align="center"><td><em>2</em></td><td><em>0</em></td><td><em>-</em></td><td><em>-</em></td><td><em>-</em></td><td>Dekódovanie</td></tr><tr align="center"><td><em>3</em></td><td><em>2</em></td><td><em>-</em></td><td>&lt;<em>MUX1 = 1, WRl = 1,<br />MEMR# = 0</em>/td&gt;</td><td><em>-</em></td><td><em>MOV AX, ADDR</em></td></tr><tr align="center"><td><em>4</em></td><td><em>1</em></td><td><em>-</em></td><td><em>MEMR# = 0,<br />RD2 = 1, WRAX = 1</em></td><td><em>0</em></td></tr><tr align="center"><td><em>5</em></td><td><em>2</em></td><td><em>-</em></td><td><em>MUX1 = 1, WRl = 1,<br />RDAX = 1, WR2 = 1,<br />MEMW# = 0</em></td><td><em>-</em></td><td><em>MOV ADDR, AX</em></td></tr><tr align="center"><td><em>6</em></td><td><em>1</em></td><td><em>-</em></td><td><em>RDAX = 1, WR2 = 1</em></td><td><em>0</em></td></tr><tr align="center"><td><em>7</em></td><td><em>1</em></td><td><em>-</em></td><td><em>MUX2 = 1, WR4 = 1</em></td><td><em>0</em></td><td><em>JMP ADDR</em></td></tr><tr align="center"><td><em>8</em></td><td><em>3</em></td><td><em>1</em></td><td><em>-</em></td><td><em>0</em></td><td><em>JZ ADDR</em></td></tr><tr align="center"><td><em>9</em></td><td><em>1</em></td><td><em>-</em></td><td><em>MUX2 = 1, WR4 = 1</em></td><td><em>0</em></td></tr><tr align="center"><td><em>10</em></td><td><em>3</em></td><td><em>3</em></td><td><em>-</em></td><td><em>7</em></td><td><em>JNC ADDR</em></td></tr><tr align="center"><td><em>11</em></td><td><em>1</em></td><td><em>-</em></td><td><em>-</em></td><td><em>0</em></td></tr><tr align="center"><td><em>12</em></td><td><em>2</em></td><td><em>-</em></td><td><em>MUX1 = 1, WR1 = 1,<br />IOR# = 0</em></td><td><em>-</em></td><td><em>IN AX, ADDR</em></td></tr><tr align="center"><td><em>13</em></td><td><em>1</em></td><td><em>-</em></td><td><em>IOR# = 0,<br />RD2 = 1, WRAX = 1</em></td><td><em>0</em></td></tr><tr align="center"><td><em>14</em></td><td><em>2</em></td><td><em>-</em></td><td><em>MUX1 = 1, WRl = 1,<br />RDAX = l, WR2 = 1,<br />IOW# = 0</em></td><td><em>-</em></td><td><em>OUT ADDR, AX</em></td></tr><tr align="center"><td><em>15</em></td><td><em>1</em></td><td><em>-</em></td><td><em>RDAX = 1, WR2 = 1</em></td><td><em>0</em></td></tr><tr align="center"><td><em>16</em></td><td><em>2</em></td><td><em>-</em></td><td><em>RDAX = 1, WT1 = 1</em></td><td><em>-</em></td><td><em>ADD AX, BX</em></td></tr><tr align="center"><td><em>17</em></td><td><em>2</em></td><td><em>-</em></td><td><em>RDBX = 1, WT2 = 1</em></td><td><em>-</em></td></tr><tr align="center"><td><em>18</em></td><td><em>1</em></td><td><em>-</em></td><td><em>Fl = 0, F2 = 0, RDALU = 1,<br />WRAX = 1</em></td><td><em>0</em></td></tr></tbody></table><p>Predpokladáme, že po inicializácii sú registre <em>PC</em> a <em>MPC</em> vynulované, takže procesor začína činnosť mikroprogramom pre výber a dekódovanie inštrukcie <em>(MPC=0).</em> Program bude takisto začínať na adrese <em>0 (PC=0).</em> Všimneme si, že mikroprogram na realizáciu každej inštrukcie končí mikroskokom na adresu <em>0</em> (v pamäti mikroinštrukcií), t.j. nasleduje výber ďalšej inštrukcie z pamäte.</p><p><strong>Určenie operačných kódov inštrukcií</strong></p><p>Ak by sme nepoužili žiadnu <em>mapovaciu logiku,</em> priamo z pamäte mikroinštrukcií môžeme určiť operačné kódy jednotlivých inštrukcií - budú to <em>štartovacie adresy zodpovedajúcich mikroprogramov.</em></p><table border="0" cellpadding="5"><tbody><tr><td colspan="2"><strong>Inštrukcia</strong></td><td><strong>Operačný kód</strong></td></tr><tr><td><em>MOV</em></td><td><em>AX, ADDR</em></td><td align="center"><em>3</em></td></tr><tr><td><em>MOV</em></td><td><em>ADDR, AX</em></td><td align="center"><em>5</em></td></tr><tr><td><em>JMP</em></td><td><em>ADDR</em></td><td align="center"><em>7</em></td></tr><tr><td><em>JZ</em></td><td><em>ADDR</em></td><td align="center"><em>8</em></td></tr><tr><td><em>JNC</em></td><td><em>ADDR</em></td><td align="center"><em>10</em></td></tr><tr><td><em>IN</em></td><td><em>AX, ADDR</em></td><td align="center"><em>12</em></td></tr><tr><td><em>OUT</em></td><td><em>ADDR, AX</em></td><td align="center"><em>14</em></td></tr><tr><td><em>ADD</em></td><td><em>AX, BX</em></td><td align="center"><em>16</em></td></tr></tbody></table><p><strong><em>Mapovacia logika</em></strong> slúži na prevod operačného kódu inštrukcie na štartovaciu adresu zodpovedajúceho mikroprogramu, takže v prípade jej použitia môžeme pre každú inštrukciu zvoliť kód podľa vlastného výberu.</p><h4>4.2.2.6 CISC a RISC procesory</h4><ul><li><em><strong>Procesor s architektúrou CISC</strong> (Complex Instruction Set Computer)</em> sa vyznačuje <em>zložitým inštrukčným súborom,</em> ktorý je navrhnutý tak, aby priamo podporoval preklad z vyšších programovacích jazykov do strojového kódu procesora. Používa sa <em>veľa spôsobov adresácie operandov,</em> inštrukcie realizujú aj <em>zložitejšie,</em> napr. reťazcové <em>operácie,</em> je implementovaná <em>priama podpora niektorých funkcií operačného systému,</em> dodržiava sa k<em>ompatibilita inštrukčného súboru v rodinách procesorov</em> zdola nahor atď. Zabezpečenie všetkých týchto vlastností si vyžaduje zložitú <em>mikroprogramovú riadiacu jednotku.</em> Tým sú samozrejme dané aj niektoré nevýhody takýchto procesorov - zložité inštrukcie si vyžadujú pre svoju realizáciu veľký súbor <em>mikroinštrukcií</em> a podporných technických prostriedkov. Technické prostriedky na podporu mikroprogramovania zaberajú na čipe veľkú plochu, čím je daná aj vyššia cena. Realizácia inštrukcií vzhľadom na použitie mikroprogramovej riadiacej jednotky trvá dlhšiu dobu. Iba malá podmnožina inštrukčného súboru tvorí väčšiu časť programov, pričom zložitejšie inštrukcie sa využívajú málo. Zložité inštrukcie dokonca môžu nepriaznivo ovplyvňovať optimalizáciu prekladu zložitejších jazykových konštrukcií vyšších programovacích jazykov. Predstaviteľmi procesorov <em>CISC</em> sú napr. procesory počítačov radu <em>IBM 43xx, VAX 11/780</em> alebo mikroprocesory rodiny <em>Intel 80x86.</em></li><li><em><strong>Procesor s architektúrou RISC</strong> (Reduced lnstruction Set Computer)</em> sa vyznačuje <em>redukovaným inštrukčným súborom.</em> Inštrukcie sú <em>jednoduché,</em> preto ich vykonanie trvá veľmi krátko (typicky sa vykonávajú v <em>jednom strojovom cykle</em>), používa sa <em>málo spôsobov adresácie operandov</em> (obyčajne iba inštrukcie typu <em>čítanie/zápis z/do hlavnej pamäte</em>), <em>väčší počet univerzálnych registrov</em> (desiatky až stovky). Riadiaca jednotka je jednoduchšia, obyčajne je to riadiaca jednotka <em>s pevnou logikou.</em> Na čipe sa uvoľnila značná časť plochy, ktorá môže byť použitá napr. na implementáciu <em>numerického koprocesora</em> a <em>vyrovnávacej pamäte.</em> Vykonanie inštrukcie, uloženej v tejto vyrovnávacej pamäti, je rýchlosťou porovnateľné s vykonaním mikroinštrukcie. Program, v ktorom sa nachádzajú aj zložitejšie inštrukcie, je síce pri procesore <em>CISC</em> kratší, ako pri procesore <em>RISC</em> (procesor <em>RISC</em> musí tieto zložitejšie inštrukcie nahradiť postupnosťou svojich jednoduchých inštrukcií), ale vzhľadom na réžiu procesora <em>CISC</em> (musí inštrukciu dekomponovať na postupnosť mikroinštrukcií) je jeho vykonanie procesorom <em>RISC</em> rýchlejšie. Predstaviteľmi procesorov <em>RISC</em> sú napr. procesory <em>SPARC, Motorola 88000, Transputer</em> fy <em>INMOS</em> atď.</li></ul><h3>4.2.3 Zvyšovanie výkonnosti procesorov</h3><h4>4.2.3.1 Zvyšovanie pracovnej frekvencie</h4><p>Zdokonaľovanie technológie výroby integrovaných obvodov viedlo k zmenšovaniu fyzických rozmerov jednotlivých súčiastok na čipe a tým k ich priblíženiu. Zmenšenie oneskorenia šírenia signálov umožnilo podstatné zvýšenie pracovnej frekvencie procesorov. Ak pracovné frekvencie prvých mikroprocesorov boli rádovo jednotky MHz, pracovné frekvencie súčasných procesorov sa pohybujú už v jednotkách GHz.</p><p>Vzhľadom na fyzikálne obmedzenia (stavebné prvky musia mať isté minimálne rozmery, obťažný odvod tepla z integrovaného obvodu s veľmi veľkou hustotou integrácie atď.) sú možnosti ďalšieho prudkého zvyšovanie pracovnej frekvencie obmedzené. Ďalej, zvýšením pracovnej frekvencie procesora vznikol nový zásadný problém - preklenutie rádových <em>rozdielov v rýchlosti procesora</em> a <em>prístupovej doby pamätí a V/V zariadení.</em></p><h4>4.2.3.2 Výpočty v pohyblivej rádovej čiarke</h4><p>Štandardný univerzálny procesor má obyčajne iba inštrukcie pre celočíselnú aritmetiku a operácie v pohyblivej rádovej čiarke sa preto musia vykonávať pomocou programu. Toto programové riešenie však veľmi zdržuje celý výpočet, preto boli vytvorené špecializované procesory pre výpočty v pohyblivej rádovej čiarke. Tieto procesory sú obyčajne <strong><em>pasívne,</em></strong> to znamená, že samotné si nedokážu vybrať inštrukciu z pamäte a musí to za nich vykonať hlavný (univerzálny) procesor. Program pre tento špecializovaný procesor je potom súčasťou programu hlavného procesora. Špecializovaný procesor pre operácie v pohyblivej rádovej čiarke sa potom označuje ako <strong><em>numerický koprocesor.</em></strong> Okrem základných aritmetických operácií vie koprocesor realizovať aj napr. niektoré <em>transcendentálne</em> a iné funkcie. Súčasné procesory už majú numerický koprocesor integrovaný priamo na čipe spolu s univerzálnym procesorom.</p><h4>4.2.3.3 Predvýber inštrukcií</h4><p>Z obsahu pamäte mikroinštrukcií (tab. 3) vidíme, že vykonávanie inštrukcií si nevyžaduje, aby procesor v každom cykle pristupoval k zbernici. To znamená, že zbernica nieje využitá počas všetkých hodinových cyklov. Na druhej strane, počas výberu a dekódovania inštrukcií sú aj niektoré časti procesora nevyužité. Ďalšou skutočnosťou je rozdiel medzi rýchlosťou procesora a dobou prístupu pamäte. Od týchto poznatkov bol už iba krok k myšlienke oddeliť výberovú a výkonnú fázu inštrukcií takým spôsobom, aby jednotky, ktoré tieto činnosti realizujú, mohli pracovať nezávisle.</p><p><em><strong>Jednotka predvýberu inštrukcií</strong> (Prefetch Unit)</em> vyberá inštrukcie z pamäte a ukladá ich do <em>frontu predvýberu (Prefetch Queue)</em> v procesore zakaždým, keď je zbernica voľná (t.j. neprenášajú sa údaje). Inštrukcie na dekódovanie sa potom vyberajú už nie z hlavnej pamäte, ale z tohto frontu predvýberu. Týmto sa dosiahli súčasne dve dôležité výhody. Prvou je to, že rýchly procesor nemusí čakať na pomalú pamäť pri výbere inštrukcií (front predvýberu je rýchlosťou porovnateľný s rýchlosťou procesora), druhou výhodou je efektívne využitie vonkajšej zbernice počítača.<br />Predvýber inštrukcií robí <em>lineárne,</em> t. j. inštrukcie sa predvyberajú z pamäte v poradí, v akom nasledujú za sebou. Je zrejmé, že v prípade, ak sa narazí na skokovú inštrukciu, front predvýberu je potrebné vyprázdniť a začať inštrukcie predvyberať z adresy, uvedenej v skokovej inštrukcii. Tým môže dôjsť k istému zníženiu efektívnosti. Tento problém vzniká najmä pri <em>podmienených skokových inštrukciách,</em> kedy vopred nie je známe, či sa skok uskutoční alebo nie.</p><h4>4.2.3.4 Prúdové spracovanie inštrukcií</h4><p><strong><em>Inštrukčný cyklus</em></strong> sa vo všeobecnosti skladá z týchto fáz:</p><p><em>1. výber inštrukcie z pamäte,<br />2. dekódovanie inštrukcie,<br />3. výber operandov (ak sú v pamäti alebo vo vstupnom zariadení. Ak sú operandy v registroch, táto fáza odpadá),<br />4. vykonanie požadovanej operácie nad operandmi,<br />5. zápis výsledku do pamäte alebo výstupného zariadenia (ak má výsledok zostať v registri, táto fáza odpadá).</em></p><p>Pre zjednodušenie predpokladajme, že všetky inštrukcie, ktoré sú v procesore spracúvané, majú svoje operandy uložené v registroch procesora a tu budú uložené aj výsledky. Potom sa inštrukčný cyklus bude skladať z týchto fáz:</p><p><em>1. výber inštrukcie z pamäte,<br />2. dekódovanie inštrukcie,<br />3. vykonanie operácie.</em></p><p>Nech každá fáza trvá rovnako dlho a tento čas označme <em>t.</em> V nami navrhnutom procesore potom vykonanie jednej inštrukcie bude trvať <em>3t.</em> Vykonanie dvoch inštrukcií bude trvať <em>6t,</em> troch <em>9t</em> atď. Grafické zobrazenie tejto situácie je na obr. 4.15a. Symboly <em>I1, I2, I3</em> v spodnej časti obrázku vyznačujú okamih, kedy príslušná inštrukcia vstupuje do procesora na spracovanie, v hornej časti obrázku tieto symboly vyznačujú okamih, kedy sú na výstupe procesora poskytnuté výsledky príslušnej inštrukcie.</p><p>Nech je však každá fáza realizovaná nezávislou funkčnou jednotkou, pričom tieto jednotky sú zapojené za sebou, ako je naznačené na obr. 4.14. Fázu <em>1</em> realizuje jednotka <em>FETCH,</em> fázu <em>2</em> jednotka <em>DECODE</em> a fázu <em>3</em> jednotka <em>EXECUTE.</em></p><div style="text-align: center"><img src="../files/obrazky/obr_34.png" border="0" alt="34" width="774" height="226" /></div><br /><div align="center">OBR. 4.14. Procesor so zreťazenými funkčnými jednotkami</div><p>Keď sa budú teraz inštrukcie spracúvať, prvá inštrukcia <em>I1</em> sa za čas <em>t</em> jednotkou <em>FETCH</em> vyberie a dostane sa na výstup, ktorý je súčasne vstupom jednotky <em>DECODE.</em> Pretože jednotka <em>FETCH</em> sa uvoľnila, môže vybrať druhú inštrukciu <em>I2.</em> Za čas <em>t</em> sa inštrukcia <em>I2</em> vyberie a v tomto istom čase sa inštrukcia <em>I1</em> dekóduje a dostane sa na vstup jednotky <em>EXECUTE.</em> Za ďalší čas <em>t</em> jednotka <em>FETCH</em> vyberie už tretiu inštrukciu <em>I3,</em> inštrukcia <em>I2</em> je dekódovaná a <em>I1</em> je už vykonaná.</p><p>Teraz na obr. 4.15b vidíme, že vykonanie prvej inštrukcie I1 trvá síce rovnako ako v predchádzajúcom prípade čas <em>3t,</em> ale vykonanie každej nasledujúcej inštrukcie už iba <em>t,</em> čím sa rýchlosť spracovania podstatne zvýšila.</p><p>Samozrejme, v reálnom procesore treba ešte riešiť problémy, ktoré vznikajú s prístupom procesora k operandom v pamäti resp. V/V zariadeniach.</p><p>&#160;</p><div style="text-align: center"><a href="../files/obrazky/obr_35.png"><img src="../files/obrazky/obr_35_small.png" border="0" width="600" height="181" /></a></div><p>&#160;</p><p align="center">OBR. 4.15. Porovnanie rýchlosti spracovania inštrukcií v procesore bez zreťazenia (a) a v zreťazenom procesore (b)</p><h4>4.2.3.5 Paralelné vykonávanie inštrukcií</h4><p>Treba poznamenať, že stále ide o program pre procesor s jedným prúdom inštrukcií a jedným prúdom údajov. Programátor sa aj pri tomto spracovaní stále díva na inštrukcie tak, ako keby boli spracúvané iba sekvenčne. Paralelne je možné vykonať iba tie inštrukcie, ktoré za sebou bezprostredne nasledujú a pritom nie sú od seba závislé, t.j. jedna nemôže poskytovať výsledok, ktorý iná používa ako operand <em>(údajová nezávislosť)</em> a takisto nesmú byť zviazané cez príznaky <em>(riadiaca nezávislosť).</em> Tie inštrukcie, ktoré nieje možné vykonať paralelne, sú vykonané sekvenčne.<br /><em>Vnútorný mechanizmus procesora</em> rozhoduje o tom, ktoré inštrukcie budú vykonané paralelne. Procesor musí mať samostatné kompletné jednotky pre paralelné vykonanie inštrukcií. Reálne sa používa napr. <em>párovanie inštrukcií</em> (procesor <em>PENTIUM</em>) [2].</p><h3>4.2.4 Prerušovací systém procesora</h3><p>Charakteristickým znakom súčasných procesorov je vyspelý <em>prerušovací systém,</em> ktorý umožňuje efektívnu implementáciu viacpoužívateľských a viacprogramových <em>operačných systémov</em> a rýchlu odozvu na <em>externé udalosti.</em></p><p>Predstavme si situáciu, že procesor vykonáva program a zrazu nastane požiadavka okamžitej obsluhy novej <em>udalosti.</em> Procesor musí <em>prerušiť</em> vykonávanie práve bežiaceho programu a začať vykonávať nový program - <em>obslužný program prerušenia.</em> Po skončení obslužného programu bude procesor pokračovať v pôvodnom - <em>prerušenom</em> programe.</p><p><strong><em>Prerušenie</em></strong> sa teda skladá z týchto krokov:</p><p><em>1. prijatie požiadavky na prerušenie,<br />2. odloženie stavu procesora,<br />3. zistenie zdroja prerušenia,<br />4. vykonanie zodpovedajúceho obslužného programu prerušenia,<br />5. obnovenie pôvodného stavu procesora,<br />6. pokračovanie v prerušenom programe.</em></p><p><em>K bodu 1.</em><br />Požiadavka na <em>externé</em> prerušenie môže prísť v ľubovoľnom okamihu, t.j. aj uprostred vykonávania inštrukcie. S obsluhou prerušenia (t.j. odloženie stavu procesora atď.) sa však začne až po dokončení práve vykonávanej inštrukcie.</p><p><em>K bodu 2.</em><br /><strong><em>Okamžitý stav procesora</em></strong> je charakterizovaný obsahom všetkých registrov procesora. Jedným z registrov je <em>programové počítadlo,</em> ktoré obsahuje adresu nasledujúcej inštrukcie. Inštrukciou, ktorá sa nachádza na tejto adrese, sa bude pokračovať po skončení obsluného programu prerušenia. <em>Stav procesora sa odkladá do zásobníka</em> (pozri časť 4.2.2.2). Použitie zásobníka umožňuje aj <em>hniezdenie prerušení,</em> to znamená, že počas obsluhy jedného prerušenia môže prísť k akceptovaniu ďalšieho prerušenia <em>s vyššou prioritou.</em></p><p><em>K bodu 3.</em><br />V počítači môže byť viac zdrojov prerušenia, ktoré musia byť <em>samostatne identifikovateľné.</em> Procesor musí zistiť, ktorý zdroj prerušenia požaduje obsluhu, aby vedel odštartovať zodpovedajúci obslužný program. <em>Synchrónne prerušenia</em> majú <em>pevne určené štartovacie adresy</em> obslužných programov, pri <em>asynchrónnych prerušeniach</em> sa obyčajne štartovacia adresa určí prostredníctvom <em>prerušovacieho vektora.</em></p><p><strong><em>Prerušovací vektor</em></strong> je ukazovateľ do tabuľky štartovacích adries obslužných programov prerušení. Tento vektor je načítaný procesorom z údajovej zbernice po prijatí prerušenia v špeciálnom cykle <em>potvrdenia prerušenia (Interrupt Acknowledge Cycle).</em> Každému zdroju prerušenia je priradený vlastný prerušovací vektor.</p><p><em>K bodu 5.</em><br />Obslužný program prerušenia je ukončený <em>inštrukciou návratu z prerušenia,</em> ktorá zo zásobníka <em>obnoví pôvodný stav procesora.</em></p><h4>4.2.4.1 Asynchrónne prerušenie</h4><p><strong><em>Asynchrónne prerušenie</em></strong> je prerušenie, ktoré priamo nesúvisí s vykonávanými inštrukciami a môže nastať kedykoľvek. Je to tzv. <em>externé (hardvérové) prerušenie</em> a typicky je požadované niektorým vstupno/výstupným zariadením, keď je toto <em>pripravené na prenos.</em></p><p>Procesor má zvyčajne dva prerušovacie vstupy pre externé prerušenie:</p><ul><li><strong><em>Vstup maskovateľného prerušenia.</em></strong> Inštrukčný súbor procesora obsahuje v tomto prípade špeciálne inštrukcie, ktoré umožňujú <em>povoliť</em> resp. <em>zakázať</em> prijatie požiadavky z tohto vstupu.</li><li><strong><em>Vstup nemaskovaieľného prerušenia.</em></strong> Toto prerušenie nie je možné zakázať a typicky sa používa pri obsluhe katastrofických situácií (napr. <em>výpadok napájacieho napätia</em>).</li></ul><h4>4.2.4.2 Synchrónne prerušenie</h4><p><strong><em>Synchrónne (interné) prerušenie</em></strong> priamo súvisí s vykonávanými inštrukciami a nie je ho možné zakázať. Synchrónne prerušenie je dvojaké:</p><ul><li><strong><em>Softvérové prerušenie.</em></strong> Softvérové prerušenie je generované po vykonaní špeciálnej <em>riadiacej inštrukcie.</em> Parametrom tejto inštrukcie je <em>číslo prerušenia,</em> ktoré sa má obslúžiť. Toto prerušenie sa typicky používa pri <em>volaní funkcií operačného systému.</em></li><li><strong><em>Výnimka (Exception).</em></strong> Výnimka sa generuje automaticky, ak nastane nejaká chyba pri vykonaní inštrukcie (napr. <em>nedefinovaný operačný kód, delenie nulou, pokus o zápis do oblasti, kde sú uložené inštrukcie, sprístupňovaný segment sa nenachádza v hlavnej pamäti</em> atď.).</li></ul><p>Využitie prerušovacieho systému procesora pri prenose údajov medzi počítačom a vstupno/výstupným zariadením si ukážeme v časti 4.4.5.</p><h2>4.3 Pamäťový podsystém počítača</h2><p><strong><em>Pamäťový podsystém počítača</em></strong> slúži jednak na uloženie programu a údajov, ktoré sa práve používajú, ako aj na ich archiváciu.</p><h3>4.3.1 Hierarchická organizácia pamäťového podsystému počítača</h3><p>Pamäťové prostriedky počítača je možné rozdeliť do niekoľkých úrovní, ktoré sa líšia spôsobom použitia v procese spracovania informácií. Jednotlivé úrovne majú pritom aj rozdielnu kapacitu a operačnú rýchlosť.<br />Na obr. 4.16 je nakreslená hierarchická organizácia pamäťového podsystému počítača. Je vyznačené, ako sa pre jednotlivé úrovne zvyšuje rýchlosť a kapacita.</p><div style="text-align: center"><img src="../files/obrazky/obr_36.png" border="0" alt="36" width="401" height="444" /></div><p align="center">OBR. 4.16. Hierarchická organizácia pamäťového podsystému počítača</p><p><strong>Charakteristika jednotlivých úrovní</strong></p><ul><li><strong><em>Registre procesora</em></strong> sa nachádzajú priamo na čipe procesora. Slúžia na prechodné uchovanie informácií počas ich spracovávania v procesore. Registre sú najrýchlejšie zo všetkých častí pamäťového podsystému, t.j. majú najkratšiu <em>dobu prístupu.</em> Pod <strong><em>dobou prístupu</em></strong> rozumieme čas, ktorý uplynie od nastavenia požiadavky na pamäť (register) po poskytnutie požadovaného údaja. Počet registrov v procesore je rôzny pri rôznych typoch procesorov, sú ich jednotky až desiatky. Doba prístupu registrov je rádovo <em>jednotky nanosekúnd (ns).</em></li><li><strong><em>Hlavná (operačná) pamäť</em></strong> obsahuje práve vykonávaný program a spracúvané údaje. Ideálne by bolo, keby sa aj hlavná pamäť nachádzala na čipe procesora a dosahovala rýchlosť registrov. Toto však vo všeobecnosti technicky nie je realizovateľné vzhľadom na požadovanú <em>kapacitu pamäte. <strong>Kapacitou pamäte</strong></em> sa rozumie množstvo informácií, ktoré je schopná pamäť uchovať. Treba si uvedomiť, že programy sa bežne skladajú z niekoľko tisíc inštrukcií, pričom ešte vôbec nehovoríme o množstve spracúvaných údajov. Z tohto vyplýva, že hlavná pamäť je realizovaná ako samostatný funkčný blok, ktorý sa skladá z jedného alebo niekoľkých integrovaných obvodov. Tým, že je hlavná pamäť vzdialená od procesora, je dané prvé nevyhnutné predĺženie doby prístupu, zapríčinené konečnou dobou šírenia signálu medzi procesorom a pamäťou. Jednotlivé bunky pamäte by bolo možné realizovať podobne, ako registre procesora, pamäť by však bola veľmi rozsiahla, drahá, s veľkou spotrebou energie. Z týchto dôvodov je hlavná pamäť realizovaná odlišnými spôsobmi ako registre procesora (napr. používajú sa <em>dynamické pamäte,</em> ktoré pri nepatrných rozmeroch a nízkej spotrebe energie majú veľkú kapacitu). Na druhej strane však za zvýšenie kapacity platíme znížením rýchlosti. Doba prístupu hlavnej pamäte je rádovo <em>desiatky ns.</em> Kapacita sa pohybuje od <em>jednotiek megabajtov</em> až do <em>niekoľko gigabajtov (GB).</em></li><li><strong><em>Vonkajšie pamäte</em></strong> slúžia na uchovanie informácií, ktoré sa momentálne nepoužívajú a na archiváciu informácií. Na rozdiel od hlavnej pamäte, k vonkajším pamätiam procesor pristupuje ako <em>k vstupno/výstupným zariadeniam.</em> Ako typické vonkajšie pamäte sa používajú <em>pevné disky, diskety, kazetovo-páskové jednotky, CD-ROM</em> atď. Doba prístupu je rôzna, záleží od typu vonkajších pamätí, napr. <em>pevné disky</em> majú v súčasnosti dobu prístupu <em>jednotky milisekúnd (ms)</em> a ich kapacita dosahuje <em>niekoľko stoviek gigabajtov (GB).</em></li><li><strong><em>Vyrovnávacia pamäť (cache)</em></strong> slúži na preklenutie v podstate rádového rozdielu medzi prístupovou dobou registrov procesora a hlavnej pamäte. Je to rýchla pamäť rádovo menšej kapacity, akú má hlavná pamäť, <em>umiestnená medzi procesor a hlavnú pamäť.</em> Do vyrovnávacej pamäte sa <em>presunie časť obsahu hlavnej pamäte</em> a procesor potom sprístupňuje informácie z vyrovnávacej pamäte vyššou rýchlosťou. Samozrejme, ak nastane situácia, že požadovaná informácia sa vo vyrovnávacej pamäti nenachádza, procesor musí túto informáciu sprístupniť z hlavnej pamäte. Vyrovnávaciu pamäť riadi vlastný <em>riadiaci obvod,</em> ktorý zabezpečuje nielen presun požadovaných informácií z hlavnej pamäte do vyrovnávacej pamäte, ale rieši aj ďalšie problémy, napr. situáciu, že procesor modifikoval nejaký údaj vo vyrovnávacej pamäti. Túto zmenu je nutné kvôli zhode informácií vykonať aj v hlavnej pamäti. Kapacita vyrovnávacej pamäte býva rádovo <em>desiatky kilobajtov (kB) až jednotky megabajtov (MB)</em> a doba prístupu je rádovo <em>nanosekundy (ns).</em> Vzhľadom k pokroku technológie výroby integrovaných obvodov sa už objavila aj vyrovnávacia pamäť priamo na čipe procesora, napr. mikroprocesor <em>PENTIUM</em> má priamo na čipe integrovanú vyrovnávaciu pamäť s kapacitou <em>16 kB.</em> Aj v tomto prípade má však počítač realizovanú externú vyrovnávaciu pamäť s väčšou kapacitou a potom hovoríme o <em>dvojúrovňovej</em> vyrovnávacej pamäti.</li></ul><p>Pre úplnosť treba poznamenať, že aj rôzne periférne zariadenia (napr. <em>tlačiareň</em> alebo <em>pevný disk</em>) môžu mať vlastnú vyrovnávaciu pamäť. Táto pamäť však nesúvisí s vyššie uvedenou hierarchickou organizáciou pamäťového podsystému počítača.</p><h3>4.3.2 Rozdelenie pamätí</h3><p><strong>Podľa spôsobu prístupu k informáciám:</strong></p><ul><li><em><strong>Pamäte s náhodným prístupom</strong> (RAM - Random Access Memory).</em> Pri tomto type pamätí je doba prístupu pre jednotlivé bunky rovnaká, nezáleží od ich umiestnenia v pamäti. Typickým príkladom je <em>hlavná pamäť počítača</em> von Neumannovského typu.</li><li><em><strong>Pamäte so sekvenčným prístupom</strong> (SAM - Sequential Access Memory).</em> Pri tomto type sa adresované miesto sprístupní až po systematickom prehľadaní predchádzajúcich buniek, takže doba prístupu záleží od umiestnenia adresovanej bunky v pamäti. Je to typické napr. pre <em>páskové</em> a <em>diskové pamäte.</em></li><li><strong><em>Pamäte s asociatívnym prístupom</em></strong> alebo <em><strong>pamäte adresované obsahom</strong> (CAM - Content Access Memory).</em> Sprístupnenie pamäťového miesta sa pri asociatívnej pamäti uskutoční nie na základe adresy, ale porovnaním všetkých buniek s tzv. <em>výberovým kľúčom.</em> Tento typ pamätí sa používa v špecializovaných počítačových architektúrach (<em>asociatívne počítače, data-flow počítače</em> a pod.) a pri realizácii <em>vyrovnávacích pamätí.</em></li></ul><p><strong>Podľa možnosti čítania a zápisu:</strong></p><ul><li><em><strong>Pamäte pre čítanie a zápis</strong> (RWM - Read/Write Memory).</em> Do týchto pamätí je možné v priebehu činnosti kedykoľvek informáciu zapísať a kedykoľvek ju čítať. Typickou pamäťou <em>RWM</em> je napr. <em>hlavná pamäť počítača.</em> Niektoré typy pamätí <em>RWM</em> si po vypnutí napájacieho napätia svoj obsah uchovajú (napr. <em>pamäte s magnetickým záznamom</em>), iné svoj obsah stratia <em>(polovodičové pamäte).</em></li><li><em><strong>Pamäti iba pre čítanie</strong> (ROM - Read Only Memory).</em> Z pamäte typu <em>ROM</em> je možné informáciu iba čítať. Prvotný zápis informácie sa vykoná buď pri výrobe pamäte, alebo si ich môže v špeciálnom zariadení <em>naprogramovať</em> používateľ. Typickou vlastnosťou pamätí <em>ROM</em> je to, že si uchovajú svoj obsah aj po vypnutí napájacieho napätia.</li></ul><h3>4.3.3 Hlavná pamäť počítača</h3><p><strong><em>Hlavná pamäť počítača</em></strong> obsahuje práve vykonávaný program a spracúvané údaje. Je to pamäť s náhodným prístupom (RAM) a obyčajne sa skladá z dvoch častí, z ktorých jedna je typu <em>ROM</em> a druhá <em>RWM.</em> Z hľadiska <em>fyzickej realizácie</em> je hlavná pamäť vytvorená z <em>polovodičových pamätí.</em></p><p><strong>Polovodičové pamäte</strong></p><p><strong><em>Polovodičové pamäte typu RWM</em></strong> sú realizované na polovodičovom čipe a vyhotovujú sa ako <em>statické</em> alebo <em>dynamické.</em></p><ul><li>Pri <em><strong>statických polovodičových pamätiach RWM</strong> (SRAM)</em> je základný pamäťový element realizovaný ako <em>preklápací obvod</em> (pozri časť 3.6.2.1). Preklápací obvod po zápise informácie zostáva v stabilnom stave, ktorý sa zmení až zápisom novej hodnoty.</li><li>Pri <em><strong>dynamických pamätiach RWM</strong> (DRAM)</em> je základný pamäťový element realizovaný pomocou <em>parazitnej kapacity,</em> ktorá sa pri zápise nabije. Vplyvom zvodového prúdu sa však elektrický náboj postupne vybíja a po istom čase by prišlo k jeho strate, a tým aj k strate zaznamenanej informácie. Z tohto dôvodu je nutné pri dynamických pamätiach periodicky obnovovať náboje na parazitných kapacitách. Táto činnosť sa nazýva <em><strong>občerstvovanie dynamickej pamäte</strong> (Refresh).</em> Na obr. 4.17 je naznačený spôsob realizácie jedného bitu v dynamickej pamäti. Kondenzátor, ktorý predstavuje parazitnú kapacitu, je nakreslený čiarkované, pretože nejde o samostatný prvok, ale parazitná kapacita je iba dôsledkom špeciálnej technologickej realizácie tranzistora.</li></ul><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/obr_37.png" border="0" alt="37" width="375" height="358" /></div><br /><p>&#160;</p><div align="center">OBR. 4.17. Realizácia jedného bitu v dynamickej pamäti</div><p>Obsah polovodičových pamätí <em>RWM,</em> nezáleží či sú statické alebo dynamické, sa po vypnutí napájacieho napätia <em>stratí.</em></p><p><strong><em>Polovodičové pamäte ROM</em></strong> si uchovajú svoj obsah aj po vypnutí napájacieho napätia. Okrem polovodičových pamätí <strong><em>ROM.</em></strong> u ktorých je <em>prvotný zápis informácie vykonaný už pri výrobe pamäte</em> (poslednou technologickou maskou), existujú aj <em>používateľom programovateľné polovodičové pamäte ROM.</em></p><li><em><strong>Pamäť typu PROM</strong> (PROM - Programmable ROM)</em> je jedenkrát naprogramovateľná polovodičová pamäť <em>ROM.</em> Naprogramovanie je <em>trvalé,</em> to znamená, že zmena obsahu pamäte po naprogramovaní už nie je možná.</li><li><strong><em>Pamäte typu EPROM</em></strong> sú programovateľné pamäte <em>ROM</em> s možnosťou vymazania a opätovného naprogramovania (<em>EPROM - Erasable PROM.</em> Pamäť sa maže pôsobením <em>ultrafialového žiarenia</em> na pamäťové elementy. Aby sa to dalo uskutočniť, pamäť má špeciálne puzdro, kde nad pamäťovými elementmi je <em>okienko z kremičitého skla.</em>).</li><li><strong><em>Pamäte typu EEPROM</em></strong> sú elektricky mazateľné pamäte <em>PROM (<strong>EEPROM</strong> - Electrically Erasable PROM).</em></li><h4>4.3.3.1 Stavebné prvky hlavnej pamäte</h4><p>Ako bolo uvedené v predchádzajúcej časti, hlavná pamäť je realizovaná z polovodičových pamätí. Tieto pamäte sú fyzicky realizované ako <em>integrované obvody.</em></p><p>Organizácia pamäťových buniek v rámci jedného integrovaného obvodu je v súčasnosti v podstate dvojaká:</p><ul><li><em>Statické pamäte RWM a pamäte ROM (PROM, ...)</em> majú obyčajne <strong><em>slabikovú organizáciu,</em></strong> t.j. do jednej bunky pamäte je možné uložiť <em>slabiku (Bajt).</em> Šírka údajovej zbernice pamäte je potom samozrejme <em>8 bitov. Kapacita pamäte</em> sa pri slabikovej organizácii udáva v <em>bajtoch (B)</em> a vypočíta sa ako mocnina 2<sup>n</sup>, kde <em>n</em> označuje šírku adresovej zbernice pamäte.</li><li><em>Dynamické pamäte RWM</em> majú obyčajne <strong><em>bitovú organizáciu,</em></strong> t.j. do jednej bunky pamäte je možné uložiť <em>1 bit.</em> Šírka údajovej zbernice pamäte je potom iba <em>1 bit. Kapacita pamäte</em> sa pri bitovej organizácii udáva v <em>bitoch (b)</em> a vypočíta sa ako mocnina 2<sup>n</sup>, kde <em>n</em> označuje šírku adresovej zbernice pamäte.</li></ul><p>Reálne má hlavná pamäť minimálne <em>slabikovú organizáciu.</em> Preto ak sa na jej výstavbu použijú <em>pamäte s bitovou organizáciou,</em> pri slabikovej organizácii hlavnej pamäte je potrebné použiť <em>osmice integrovaných obvodov,</em> ktoré majú <em>spoločný výberový signál a spoločné riadiace a adresové signály. Údajový vodič</em> každej pamäte v osmici je pripojený na <em>iný bit</em> údajovej zbernice počítača.</p><h4>4.3.3.2 Pripojenie pamäte k zbernici počítača</h4><p><strong><em>Zbernica počítača</em></strong> sa skladá z <em>adresovej, údajovej</em> a <em>riadiacej sekcie.</em> Teraz si ukážeme, akým spôsobom sa pripoja jednotlivé obvody, ktoré vytvárajú hlavnú pamäť, k zbernici. Kvôli jednoduchosti budeme uvažovať obvody typu <em>RWM</em> so <em>slabikovou</em> organizáciou.</p><p>Na obr. 4.18 je naznačené pripojenie viacerých pamäťových obvodov k zbernici počítača.</p><div style="text-align: center"><a href="../files/obrazky/obr_38.png"><img src="../files/obrazky/obr_38_small.png" border="0" width="500" height="308" /></a></div><br /><div align="center">OBR. 4.18. Pripojenie pamäťových obvodov k zbernici počítača</div><p>&#160;</p><p>Šírka údajovej zbernice počítača je <em>8 bitov,</em> šírka adresovej zbernice <em>a-bitov.</em> Riadiaca zbernica sa skladá zo <em>4</em> signálov, ktoré sú riadené procesorom. Majú tento význam:</p><table border="0"><tbody><tr><td><em>MEMR#</em> </td><td>- signál čítania z pamäte,</td></tr><tr><td><em>MEMW#</em></td><td>- signál zápisu do pamäte,</td></tr><tr><td><em>IOR#</em> </td><td>- signál čítania zo vstupného zariadenia,</td></tr><tr><td><em>IOW#</em></td><td>- signál zápisu do výstupného zariadenia.</td></tr></tbody></table><p>Počas práce s pamäťou sú riadiace signály <em>IOR#</em> a <em>I0W#</em> v neaktívnej úrovni.</p><p>Všetky pamäťové obvody <em>Modul0, ... Modul(k-1)</em> sú pripojené na zbernicu počítača <em>paralelne.</em> Všimneme si, že na adresové vstupy pamäťových obvodov je pripojených <em>spodných n bitov</em> adresy, ktoré slúžia na adresovanie <em>jednej konkrétnej bunky</em> vo vybranom pamäťovom obvode.<br />Dekóder <em>DEC1</em> na základe <em>zvyšnej časti adresy</em> na adresovej zbernici počítača určuje, s ktorým pamäťovým obvodom sa bude pracovať. Je typu <em>1 z n,</em> takže vždy iba jediný pamäťový obvod môže byť aktívny.</p><p><strong>Typické vstupy a výstupy pamäťových obvodov typu RWM</strong></p><p><em>ADDR</em> - na tento vstup je vyvedená <em>n-bitová adresová zbernica</em> pamäte.<br /><em>DATA</em> - obojsmerná (v našom prípade <em>8-bitovä</em>) <em>údajová zbernica</em> pamäte.<br /><em>OE#</em> - vstup, slúžiaci na <em>uvoľnenie trojstavových výstupov</em> údajovej zbernice pamäte pri čítaní údajov.<br /><em>WE#</em> - <em>zapisovací vstup.</em> Aktívna úroveň na tomto vstupe <em>(log.0)</em> zapisuje údaje z údajovej zbernice do pamäťových elementov pamäte.<br /><em>CS#</em> - <em>výberový vstup pamäte.</em> Tak čítanie, ako aj zápis z/do pamäte sa môže uskutočniť iba vtedy, ak je na tomto vstupe aktívna úroveň, t.j. <em>log.0.</em> Výberový vstup slúži na to, aby sa pri každom prístupe k hlavnej pamäti pracovalo vždy iba s jedným pamäťovým obvodom.</p><p><strong>Typické vstupy a výstupy pamäťových obvodov typu <em>ROM</em></strong></p><p>Obvody typu <em>ROM</em> majú rovnaké signály ako obvody typu <em>RWM,</em> chýba im však signál <em>WE#</em> (do týchto obvodov sa nedá zapisovať).</p><h4>4.3.3.3 Komunikácia procesora s pamäťou</h4><ul><li><strong><em>Čítanie z pamäte.</em></strong> Procesor musí nastaviť na adresovej zbernici platnú adresu pamäťovej bunky, z ktorej chce načítať informáciu a nastaviť aktívnu úroveň signálu pre čítanie z pamäte <em>MEMR#.</em> Signál musí byť v aktívnej úrovni dostatočne dlhý čas. Po istom čase <em>(doba prístupu pamäte)</em> pamäť vyšle na údajovú zbernicu platnú informáciu.</li><li><strong><em>Zápis do pamäte.</em></strong> Procesor musí nastaviť na adresovej zbernici adresu bunky pamäte, do ktorej chce zapísať a na údajovú zbernicu vyslať platné údaje. Potom môže nastaviť do aktívnej úrovne signál pre zápis do pamäte <em>MEMW#.</em> Je potrebné dodržať jednak istú minimálnu <em>dobu trvania</em> signálu <em>MEMW#,</em> ako aj dostatočný <em>predstih</em> a <em>presah údajov</em> voči tomuto signálu, tak ako je naznačené na obr. 4.19.</li></ul><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/obr_39.png" border="0" alt="39" width="779" height="635" /></div><br /><p>&#160;</p><p align="center">OBR. 4.19. Signálové sledy pre čítanie a zápis z/do pamäte</p><h3>4.3.4 Správa a ochrana hlavnej pamäte</h3><p>Ako sme už uviedli v časti 4.2.2.3, existuje veľa spôsobov adresácie operandov. Pri ľubovoľnom spôsobe adresácie je výsledkom tzv. <em>efektívna</em> alebo <em>absolútna adresa,</em> t.j. adresa, ktorú procesor vysiela na adresovú zbernicu. Hlavná pamäť počítača sa navonok javí ako <em>lineárny priestor pamäťových buniek,</em> ktoré nasledujú spojité za sebou a líšia sa iba svojou adresou. Z tohto dôvodu sa nasledujúca rovnosť javí ako celkom prirodzená:</p><p><em>logický adresový priestor = fyzický adresový priestor</em></p><p>pričom <em>logický adresový priestor</em> je priradený <em>programu</em> a <em>fyzický adresový priestor</em> zodpovedá <em>hlavnej pamäti počítača.</em> Nie vždy sa však uvedené priradenie dá realizovať.</p><p>Zavedenie <strong><em>správy pamäte</em></strong> má tri hlavné príčiny:</p><ol><li><em>Program môže vyžadovať pre svoje vykonanie väčší logický adresový priestor, ako je fyzický adresový priestor, ktorý má počítač k dispozícii.</em></li><li><em>Vyžaduje sa priradenie a rozdelenie fyzického adresového priestoru viacerým používateľským programom súčasne.</em></li><li><em>Požaduje sa ochrana fyzického adresového priestoru, priradeného jednému používateľskému programu, pred ovplyvňovaním iným používateľskými programom.</em></li></ol><p><em>K bodu 1.</em><br />Táto požiadavka sa rieši vytvorením tzv. <em>virtuálnej pamäte.</em> Jej vytvorenie je viazané na existenciu rýchlej vonkajšej pamäte s dostatočnou kapacitou, napr. pevný disk.</p><p><em>K bodu 2.</em><br />Musí byť k dispozícii jednoduchý mechanizmus pre <em>dynamickú relokáciu,</em> t.j. možnosť premiestňovania oblastí s danou logickou adresou na rôzne fyzické adresy.</p><p><em>K bodu 3.</em><br />Je nutné, aby každá oblasť fyzickej pamäte bola vybavená tzv. <em>prístupovými právami,</em> ktoré definujú, <em>kto</em> ju môže používať a <em>akým spôsobom (privilegované úrovne, spôsob použitia - čítanie, čítanie aj zápis, vykonanie atď.)</em></p><p><em>Preklad logickej adresy na fyzickú adresu</em> a <em>kontrolu prístupových práv</em> pri zavedení správy pamäte vykonáva špeciálny blok procesora, ktorý sa nazýva <em><strong>jednotka správy pamäte</strong> (MMU - Memory Management Unit).</em></p><h4>4.3.4.1 Virtuálna pamäť</h4><p>Princíp <strong><em>virtuálnej pamäte</em></strong> spočíva v tom, že nie celý program alebo všetky údaje sa nachádzajú naraz v hlavnej pamäti počítača. Nachádza sa tam iba tá časť, ktorá sa práve používa, zvyšná časť programu alebo údajov je uložená na rýchlej vonkajšej pamäti, napr. na pevnom disku. V prípade, ak procesor chce vybrať inštrukciu alebo sprístupniť údaj, ktorý sa v hlavnej pamäti nenachádza, treba zabezpečiť, aby sa príslušná časť programu alebo údajov preniesla z vonkajšej do hlavnej pamäte.</p><p>Najpoužívanejšími spôsobmi realizácie virtuálnej pamäte je segmentovanie a stránkovanie.</p><p><strong>Segmentovanie</strong></p><p>Podstatou <strong><em>segmentovania</em></strong> je to, že program a údaje sa rozdelia na bloky - <strong><em>segmenty.</em></strong> Inštrukcie, resp. údaje, ktoré sú v jednom segmente, <em>spolu logicky súvisia.</em> Veľkosť segmentov môže byť rôzna. Napríklad v jednom segmente sa môže nachádzať <em>hlavný program,</em> v ďalšom <em>podprogramy,</em> v inom <em>údaje</em> atď.</p><p><strong><em>Logická adresa</em></strong> sa v prípade <em>segmentovania</em> skladá z dvoch častí, ktoré sa spracúvajú samostatne:</p><p><em>Selektor: Posunutie</em></p><p><em><strong>Posunutie</strong> (offset)</em> reprezentuje <em>vzdialenosť</em> inštrukcie alebo údaja od <em>začiatku segmentu.</em> Iba <em>posunutie</em> vystupuje ako parameter v <em>adresovej časti</em> inštrukcií.</p><p><strong><em>Selektor</em></strong> je ukazovateľ do <em>tabuľky deskriptorov segmentov.</em> Selektor sa nachádza v <em>špeciálnom</em> registri a manipuluje sa s ním nezávisle od posunutia. <strong><em>Tabuľka deskriptorov segmentov</em></strong> sa nachádza v hlavnej pamäti a sú v nej <em>deskriptory</em> všetkých segmentov.</p><p><strong><em>Deskriptor segmentu</em></strong> je záznam, ktorý tieto informácie o segmente:</p><ol><li><em><strong>Bázová adresa segmentu</strong> (Base)</em>. Je to adresa, od ktorej je segment uložený v hlavnej pamäti <em>(začiatok segmentu).</em></li><li><em><strong>Veľkosť segmentu</strong> (Limit).</em> Pre každú inštrukciu alebo údaj v danom segmente musí platiť, že <em>Offset &lt; Limit.</em></li><li><em><strong>Atribúty segmentu (Attributes).</strong> Patrí sem:</em> <ul><li><em>Informácia o prítomnosti segmentu v hlavnej pamäti.</em> Ak sa sprístupňovaný segment nenachádza v hlavnej pamäti, použije sa položka <em>4.</em> a segment sa načíta z vonkajšej pamäte.</li><li><em>Informácia o type segmentu (vykonateľný segment, vykonateľný segment s možnosťou čítania, údajový segment len pre čítanie, údajový segment pre čítanie i zápis, zásobníkový segment atď.).</em></li><li><em>Informácia o privilegovanej úrovni segmentu</em> (má význam v prípade, ak <em>viacero programov</em> môže používať ten istý segment)</li></ul></li><li><strong><em>Adresa segmentu vo vonkajšej pamäti (External).</em></strong></li></ol><p>Na obr. 4.22 je zobrazený vzťah medzi deskriptorom segmentu a segmentom. Premenná <em>VAR1</em> patrí do segmentu <em>SEG1</em> a má logickú adresu <em>SEL1:OFFSET1.</em> Segment <em>SEG1</em> je opísaný deskriptorom <em>DESC1.</em></p><p><strong><em>Fyzická adresa</em></strong> sa vypočíta tak, že k hodnote <em>bázy</em> sa pripočíta hodnota <em>posunutia.</em></p><p>Uvedený spôsob adresovania je tzv. <em>relatívne adresovanie.</em> Jeho výhodou je to, že segment je možné bez zmeny uložiť od ľubovoľnej adresy v hlavnej pamäti, stačí iba <em>zmeniť hodnotu bázy.</em></p><div align="center"><img src="../files/obrazky/42.png" border="0" alt="obr42" width="539" height="414" /> </div><p align="center">OBR. 4.22. Vzťah medzi deskriptorom segmentu a segmentom</p><p><strong>Segmentácia a využitie hlavnej pamäte</strong></p><p>V prípade segmentácie prichádza k tzv. <strong><em>externej fragmentácii.</em></strong> Táto spočíva v tom, že po niekoľkonásobnom načítaní a vylúčení rôznych segmentov z hlavnej pamäte môže nastať situácia, že segmenty sú v hlavnej pamäti rozmiestnené tak nepriaznivo, že nemôžeme už načítať do pamäte ďalší segment, aj keď súčet voľnej pamäte je väčší, ako veľkosť segmentu, ktorý chceme načítať.</p><p>V tomto prípade je potrebné urobiť <em><strong>preusporiadanie segmentov</strong> (kondenzácia)</em> - segmenty sa popresúvajú v hlavnej pamäti tak, aby voľná pamäť bola <em>spojitá.</em> Táto činnosť si však vyžaduje istý čas procesora, ktorý sa nedá využiť pre užitočný výpočet.</p><p><strong>Stránkovanie</strong></p><p>Pri <strong><em>stránkovaní</em></strong> je hlavná pamäť rozdelená na úseky rovnakej dĺžky, ktoré sa nazývajú <em><strong>stránkové rámy</strong> (page frames).</em> Stránkové rámy sú očíslované. Program i údaje sú takisto rozdelené na úseky <em>rovnakej dĺžky - <strong>stránky.</strong></em> Veľkosť stránky je rovnaká, ako veľkosť stránkového rámu.</p><p><strong><em>Logická adresa</em></strong> sa v prípade <em>stránkovania</em> skladá z dvoch častí, ktoré sú však na rozdiel od segmentovania spracovávané spoločne - <em>stránka</em> a <em>posunutie.</em></p><p><em><strong>Posunutie</strong> (offset)</em> reprezentuje <em>vzdialenosť</em> inštrukcie alebo údaja od <em>začiatku</em> stránky.</p><p><em><strong>Stránka</strong> (page)</em> je ukazovateľ do <em>tabuľky deskriptorov stránok.</em></p><p><strong><em>Tabuľka deskriptorov stránok</em></strong> sa nachádza v hlavnej pamäti a sú v nej <em>deskriptory</em> všetkých stránok.</p><p><strong><em>Deskriptor stránky</em></strong> je záznam, ktorý obsahuje tieto informácie o stránke:</p><ol><li><strong><em>Číslo stránkového rámu (Frame).</em></strong> Pretože všetky stránkové rámy majú rovnakú veľkosť, číslo stránkového rámu jednoznačne určuje umiestnenie stránky v hlavnej pamäti, t.j. adresu, od ktorej je stránka v hlavnej pamäti uložená <em>(začiatok stránky).</em></li><li><strong><em>Atribúty stránky (Attributes).</em></strong> Tieto sú rovnaké, ako atribúty segmentu.</li><li><strong><em>Adresa stránky vo vonkajšej pamäti (External).</em></strong></li></ol><p>Pretože všetky stránky majú rovnakú veľkosť, deskriptor stránky informáciu o veľkosti stránky <em>nemusí obsahovať.</em></p><p>Na obr. 4.23 je zobrazený vzťah medzi deskriptorom stránky a stránkou. Premenná <em>VAR2</em> má logickú adresu <em>PAGE2:OFFSET2.</em> Patrí do stránky <em>PAGE2,</em> ktorá je opísaná deskriptorom <em>DESC2.</em> Táto stránka je momentálne uložená v stránkovom ráme <em>FRAME1.</em></p><div align="center"><img src="../files/obrazky/43.png" border="0" alt="obr43" width="539" height="436" /> </div><p align="center">OBR. 4.23. Vzťah medzi deskriptorom stránky a stránkou</p><p>Situáciu, keď procesor chce sprístupňovať stránku, ktorá sa nenachádza v hlavnej pamäti, označujeme ako <strong><em>výpadok stránky.</em></strong></p><p><strong>Stránkovanie a využitie hlavnej pamäte</strong></p><p>V prípade stránkovania prichádza k tzv. <strong><em>internej fragmentácii.</em></strong> Táto spočíva v tom, že veľkosť programov alebo údajov nie je vo všeobecnosti celočíselným násobkom veľkosti stránky. Posledná stránka potom nie je plne využitá. Čím viac programov alebo údajových štruktúr sa v pamäti nachádza, tým viac sa prejavuje nevyužitie hlavnej pamäte. Čím je väčšia veľkosť stránky, tým je problém vypuklejší. Na druhej strane, ak zmenšíme veľkosť stránky, výrazne rastie tabuľka deskriptorov. Potrebné je zvoliť vhodný kompromis.</p><p>Okrem jednoduchého stránkovania sa používa aj <em>viacúrovňové stránkovanie,</em> prípadne sa kombinuje <em>segmentovanie a stránkovanie.</em> Vtedy hovoríme o <strong><em>stránkovaných segmentoch.</em></strong></p><h4>4.3.4.2 Technické prostriedky na podporu ochrany pamäte</h4><p>Problém <em>ochrany pamäte</em> sa čiastočne rieši vo všetkých architektúrach, ktoré podporujú segmentovanie a stránkovanie. Vo všeobecnosti sa väčší stupeň ochrany poskytuje v systémoch so segmentovaním, kde <em>mechanizmus ochrany môže byť riadený programátorom,</em> ktorý rozdeľuje program a údaje do segmentov podľa vlastného uváženia.</p><p><em>Komplexné riešenie problému ochrany pamäte si vyžaduje spoluprácu technických a programových prostriedkov počítača.</em></p><p>Technické prostriedky súčasných procesorov <em>(napr. 80x86 v privilegovanom režime) bez účasti programátora kontrolujú,</em> či sa sprístupňovaný segment <em>nachádza v hlavnej pamäti,</em> či <em>adresa</em> sprístupňovanej inštrukcie alebo údaja <em>nepresiahla limit segmentu,</em> či je <em>použitie daného typu segmentu korektné (napr. či nedochádza k výberu inštrukcie z údajového segmentu)</em> a či je <em>oprávnené použitie daného segmentu (či má žiadateľ dostatočnú privilegovanú úroveň).</em></p><p>Vykonávanie týchto činností priamo technickými prostriedkami umožňuje implementovať efektívny spôsob ochrany pamäte. Ak by sa totiž tieto činnosti vykonávali programovými prostriedkami, prichádzalo by k neúnosnému spomaleniu činnosti celého systému.</p><p>V prípade, ak technické prostriedky zistia porušenie ochrany pamäte, je vygenerovaná <em>výnimka</em> (pozri <em>Prerušovací systém procesora</em>) a úlohou <em>operačného systému</em> je daný problém vyriešiť.</p><h3>4.3.5 Vyrovnávacia pamäť (cache)</h3><p><strong><em>Vyrovnávacia pamäť (cache)</em></strong> je rýchla pamäť rádovo menšej kapacity, akú má hlavná pamäť. <em>Slúži na preklenutie v podstate rádového rozdielu medzi prístupovou dobou registrov procesora a hlavnej pamäte.</em> Do vyrovnávacej pamäte sa presunie časť obsahu hlavnej pamäte a procesor potom sprístupňuje informácie z vyrovnávacej pamäte vyššou rýchlosťou ako z hlavnej pamäte.<br />Činnosť vyrovnávacej pamäte vychádza z predpokladu, že počas vykonávania programu sa inštrukcie i údaje vyberajú postupne za sebou, tak ako sú umiestnené v hlavnej pamäti. Z tohto dôvodu, ak procesor sprístupňuje nejakú bunku v hlavnej pamäti, do vyrovnávacej pamäte sa presunie nie iba táto jediná bunka, <em>ale celá skupina po sebe nasledujúcich buniek.</em> Táto skupina buniek, označovaná ako <strong><em>riadok (line),</em></strong> tvorí základnú alokačnú jednotku vyrovnávacej pamäte.</p><p>Počas práce procesora s riadkom, ktorý je umiestnený vo vyrovnávacej pamäti, môže nastať situácia, že procesor modifikoval niektorú bunku v riadku. V tomto okamihu nastala <em>nekonzistencia</em> informácií medzi vyrovnávacou a hlavnou pamäťou. Túto situáciu rieši <em>riadiaci obvod vyrovnávacej pamäte (cache controller)</em> dvoma spôsobmi:</p><ul><li>Prvý spôsob, označovaný ako <em><strong>zápis späť</strong> (copy-back)</em> spočíva v tom, že ak sa riadok vo vyrovnávacej pamäti už stane neaktuálny a do vyrovnávacej pamäte je treba naplniť nový riadok, celý modifikovaný starý riadok je prepísaný do hlavnej pamäte.</li><li>Druhý spôsob, označovaný ako <em><strong>zápis cez vyrovnávaciu pamäť</strong> (write-through)</em> rieši problém nekonzistencie tak, že kedykoľvek procesor modifikuje niektorú bunku vo vyrovnávacej pamäti, táto zmena sa súčasne uskutoční aj v hlavnej pamäti.</li></ul><h4>4.3.5.1 Mapovanie hlavnej pamäte do vyrovnávacej pamäte</h4><p>Ako už bolo uvedené, vyrovnávacia pamäť má menšiu kapacitu ako hlavná pamäť. Treba preto nájsť spôsob, ako ľubovoľný riadok z hlavnej pamäte umiestniť do niektorého riadku vyrovnávacej pamäte. Tomuto spôsobu sa hovorí <em>mapovanie.</em></p><p>Na obr. 4.20 vidíme princíp mapovania hlavnej pamäte do vyrovnávacej pamäte.</p><div align="center"><img src="../files/obrazky/40.png" border="0" alt="obr40" width="464" height="403" /> </div><p align="center">OBR. 4.20. Princíp mapovania hlavnej pamäte do vyrovnávacej pamäte</p><p>Hlavná pamäť je rozdelená na 2<sup>t</sup> blokov, ktoré majú rovnakú veľkosť a organizáciu, ako vyrovnávacia pamäť.</p><p><em>Adresa každej bunky v hlavnej pamäti</em> je teraz rozdelená do <em>troch polí:</em></p><ol><li>Pole <strong><em>DISPL</em></strong> má <em>d</em> bitov a udáva <em>posunutie bunky v riadku</em> od začiatku riadku.</li><li>Pole <strong><em>LINE</em></strong> má <em>l</em> bitov a udáva, <em>do ktorého riadku bunka patrí.</em></li><li>Pole <strong><em>TAG</em></strong> má <em>t</em> bitov a udáva, <em>do ktorého bloku bunka patrí.</em></li></ol><p><strong>Modely vyrovnávacích pamätí</strong></p><p>V súčasnosti sa používa niekoľko modelov vyrovnávacích pamätí, <em>napr. vyrovnávacia pamäť s priamym mapovaním (Direct Mapping Cache Memory), s množinou blokov (Set Associaíive Cache Memory), plne asociatívna vyrovnávacia pamäť (Fully Associative Cache Memory).</em></p><p>Na obr. 4.21 je nakreslená vyrovnávacia pamäť s množinou blokov, ktorá sa skladá z <em>n</em> blokov.</p><div align="center"><img src="../files/obrazky/41.png" border="0" alt="obr41" width="537" height="401" /> </div><p align="center">OBR. 4.21. Vyrovnávacia pamäť s množinou blokov</p><p><strong><em>Vyhodnocovací obvod (VO)</em></strong> zisťuje, či sa riadok s adresovanou bunkou nachádza v niektorom bloku vyrovnávacej pamäte. V prípade, ak tomu tak je, signál <em>PRESENT</em> je aktívny a príslušná bunka je cez zodpovedajúce hradlo <em>G</em> sprístupnená. Pre uloženie príznakov <em>TAG</em> sa používa <em>asociatívna pamäť (CAM),</em> čím je vyhodnotenie veľmi jednoduché a rýchle. Ak požadovaný riadok vo vyrovnávacej pamäti nie je, <em>riadiaci obvod vyrovnávacej pamäte</em> musí zabezpečiť jeho načítanie z hlavnej pamäte. Ak vo vyrovnávacej pamäti nie je nijaký voľný riadok, ďalšou úlohou riadiaceho obvodu je vybrať, ktorý z riadkov bude zrušený.</p><p>Pre výber sa používajú najčastejšie dva algoritmy:</p><ul><li><em><strong>LRU</strong> (Least-Recently Used)</em> - bude vylúčený ten riadok, ktorý sa <em>najdlhší čas nepoužil.</em></li><li><em><strong>LFU</strong> (Least-Frequently Used)</em> - bude vylúčený <em>najmenej často používaný</em> riadok.</li></ul><h3>4.3.6 Vonkajšie pamäte</h3><p><strong><em>Vonkajšie pamäte</em></strong> slúžia na prechodné uchovanie informácií počas výpočtu a na archiváciu informácií. Nie sú súčasťou operačnej (hlavnej) pamäte počítača a procesor k nim pristupuje ako k <em>V/V zariadeniam.</em><br />V ďalšom uvedieme základné informácie o najpoužívanejších vonkajších pamätiach.</p><h4>4.3.6.2 Pevné disky</h4><p>Pri pevných diskoch sa používa rovnaký princíp záznamu a čítania informácií, ako pri disketách. Na rozdiel od disketovej mechaniky je však mechanika pevného disku úplne <em>uzatvorená,</em> takže pamäťové médium, ktoré sa skladá z jedného alebo niekoľkých pevných diskov, <em>nie je výmenné.</em> V prípade viacerých diskov hovoríme o <em>diskovom zväzku.</em></p><p>Magnetické hlavičky <em>sa nedotýkajú</em> priamo povrchu disku, ale plávajú vo vzdialenosti <em>niekoľkých mikrometrov</em> nad jeho povrchom. Pri vysokých prevádzkových otáčkach disku <em>(napr. 3600 . min<sup>-1</sup>)</em> by prítomnosť mechanickej nečistoty (v tomto prípade i prachovej častice) mala katastrofálne následky. Pevné disky sú tiež chúlostivé na otrasy počas prevádzky.<br />Magnetické hlavičky sú upevnené na držiaku, ktorému sa hovorí <strong><em>vystavovacie ramienko</em></strong> a pohybujú sa všetky spoločne nad rovnakým <em>valcom,</em> t.j. jednotlivé hlavičky nemôžu byť vystavované nezávisle.</p><p>Priemer používaných diskov je rovnaký, ako pri disketách, preto sú vonkajšie rozmery pevného disku v podstate rovnaké ako rozmery disketovej mechaniky.</p><p><strong><em>Rýchlosť disku</em></strong> charakterizujú dva údaje. Prvý udáva, ako dlho trvá vyhľadanie určitej informácie na disku <em>(doba prístupu),</em> druhý udáva, ako rýchlo je disk schopný informáciu preniesť <em>(rýchlosť prenosu údajov).</em><br /><strong><em>Doba prístupu</em></strong> sa skladá z dvoch častí. Najprv sa premiestni magnetická hlavička na príslušnú stopu <em>(doba vyhľadávania)</em> a potom sa čaká, kým sa pod hlavičkou bude nachádzať príslušný sektor <em>(rotačná čakacia doba).</em><br />Doba pristupuje pri súčasných pevných diskoch menšia ako <em>10 ms,</em> rýchlosť prenosu údajov dosahuje okolo <em>5 - 10 MB.s<sup>-1</sup>.</em></p><p><strong>Organizácia údajov</strong></p><p>Organizácia údajov je podobná, ako na disketách. Naviac sa tu používa výraz <em>valec (cylinder).</em><br />Pod <strong><em>valcom</em></strong> rozumieme všetky stopy rovnakého priemeru, ktoré sú umiestnené pod sebou. Počet stôp pri pevných diskoch je podstatne väčší, ako pri disketách, býva ich aj <em>viac ako 1000.</em> Počet sektorov na stopu sa pohybuje <em>od 17</em> až do <em>viac ako 50.</em> Počet bajtov na sektor býva obyčajne rovnaký ako pri disketách, t.j. <em>512.</em></p><p><strong>Výpočet kapacity pevného disku</strong></p><p>Kapacita disku sa vypočíta ako súčin:</p><p><em>(počet hlavičiek).(počet valcov).(počet sektorov).(počet bajtov na sektor)</em></p><p><strong>Krokovacie motorčeky a vychyľovacie cievky</strong></p><p>Pre pohyb vystavovacieho ramienka v mechanike pevného disku sa používajú dva rôzne spôsoby. Prvý z nich je <em>krokovací motorček,</em> druhý spôsob je <em>vychyľovacia cievka.</em></p><p><strong><em>Krokovací motorček</em></strong> je napájaný elektrickými impulzmi a po každom impulze sa jeho hriadeľ pootočí o uhol, ktorému sa hovorí <strong><em>krok.</em></strong> Jedna celá otáčka hriadeľa sa môže skladať z <em>niekoľko sto</em> krokov. Okolo hriadeľa je namotaný pružný tenký kovový pásik, spojený s vystavovacím ramienkom. Keď sa hriadeľ otáča, pásik sa buď navíja alebo odvíja, čím sa pohybuje aj vystavovacie ramienko. Jeden impulz z riadiaceho obvodu disku pootočí hriadeľ motorčeka o jeden krok a hlavičky sa tým presunú o jeden valec.</p><p>Tento systém má však niekoľko nevýhod. Prvou z nich je to, že pásik sa časom môže natiahnuť, druhou je to, že krokovací motorček sa opotrebúva a môže niekedy preskočiť aj o viac ako jeden krok.</p><p><strong><em>Vychyľovacia cievka</em></strong> má vo svojom strede kovové jadro. Keď sa cievke dodá elektrická energia, jadro sa vysúva alebo zasúva. Pretože je s ním spojené vystavovacie ramienko, súčasne sa pohybujú aj magnetické hlavičky. Ako však riadiaci obvod disku vie, ako ďaleko má jadro vysunúť ?<br />Pri krokovacom motorčeku je situácia jasná - jeden impulz znamená posun o jeden valec. Pri systéme s vychyľovacou cievkou je informácia o pozícii hlavičiek zakódovaná na disku spoločne s údajmi. Niektoré disky venujú tejto informácii jeden celý povrch, takže potom v údajoch o disku nájdeme <em>nepárny počet hlavičiek.</em> Neuvedená hlavička je použitá iba pre polohovacie informácie. Tomuto sa hovorí <em>jednoúčelový servomechanizmus.</em> Iné disky majú informáciu o polohe hlavičiek roztrúsené po celom disku a tak pre údaje používajú všetky povrchy a pri nich je udávaný <em>párny počet hlavičiek.</em> Vtedy sa hovorí o <em>vloženom servomechanizme.</em></p><p>Systém s vychyľovacou cievkou je perspektívnejší. Je rýchlejší, a okrem toho ide o tzv. <em>uzavretý riadiaci systém.</em> Vystavovacie ramienko sa pohybuje dovtedy, kým sa nezíska informácia o správnej polohe hlavičiek. Naproti tomu systém s krokovacím motorčekom vychádza z predpokladu, že valec <em>20</em> bude vždy <em>20</em> krokov od valca <em>0.</em> Časom sa však vplyvom mechanického opotrebovania jeho pozícia stále vzďaľuje. Ďalšou významnou výhodou systému s vychyľovacou cievkou je to, že po vypnutí napájacieho napätia pružina automaticky presunie hlavičky k stredu disku - disk sa sám <strong><em>zaparkuje.</em></strong></p><p><strong>Kódovanie informácie</strong></p><p>Ako už bolo uvedené, údaje sú na magnetickom médiu zaznamenané ako elementárne magnety. Pri otáčaní média sa v magnetickej hlavičke indukujú napäťové impulzy. Na reprezentáciu logických hodnôt na magnetických médiách sa teda používa <em>impulz (I)</em> resp. <em>neprítomnosť impulzu,</em> ktorú označíme ako <em>medzera (M).</em></p><p>Najjednoduchším kódovaním by teda zrejme bolo kódovanie, keby hodnote <em>log.1</em> zodpovedal <em>impulz</em> a hodnote <em>log.0 medzera,</em> t.j.:</p><p><em>log.l = I<br />log.0 = M</em></p><p>Môže však nastať situácia, že za sebou nasleduje veľa hodnôt <em>log.0.</em> Toto by potom predstavovalo dlhý čas bez impulzov, čím vzniká vážny problém. Impulzy totiž okrem toho, že reprezentujú údaje, slúžia aj na synchronizáciu vnútorných hodín <em>riadiaceho obvodu disku</em> s údajmi. Údaje sa získavajú z disku v závislosti od času, takže doba, ktorá bola použitá na <em>záznam údajov,</em> musí byť rovnaká, ako doba na <em>čítanie údajov.</em> Impulzy pomáhajú údaje a riadiaci obvod disku synchronizovať. Preto je potrebná taká kódovacia schéma, ktorá zabezpečí, že pri ľubovoľných údajoch nebude riadiaca jednotka disku veľmi dlho bez impulzu. Riešením je vloženie <em>synchronizačných bitov</em> medzi <em>údajové bity.</em></p><p><strong>Kódovanie MFM</strong></p><p><em><strong>Modifikovaná frekvenčná modulácia</strong> (MFM - Modified Frequence Modulation)</em> kóduje takto:</p><p><em>log.1 = MI<br />log.0 = ak je pred ňou log.O, tak IM<br />log.0 = ak je pred ňou log.1, tak MM</em></p><p>V kódovaní <em>MFM</em> je minimálny počet medzier <em>1</em> a maximálny počet medzier <em>3.</em> Hovoríme, že MFM má <em>1,3 obmedzenú dĺžku chodu (1,3 RLL - Run Length Limited). MFM</em> sa používa pri kódovaní <em>pružných diskov</em> a pri starších pevných diskoch.<br />V súčasnosti sa používa kódovanie <em>2,7 RLL</em> (alebo skrátene iba <em>RLL</em>), ktoré umožňuje ešte väčšiu hustotu údajov a tým lepšie využitie diskového média. Kódovacia schéma je zložitejšia. V kódovaní <em>RLL</em> majú disky okrem väčšej kapacity aj vyššiu prenosovú rýchlosť.</p><h4>4.3.6.3 Kazetovo-páskové pamäte</h4><p>Kazetovo-páskové pamäte využívajú magnetický spôsob záznamu informácií. Údaje sa zaznamenávajú na kazetu s magnetickou páskou <em>(cartridge).</em> Používa sa viac typov kaziet, ktoré sa líšia svojou veľkosťou a kapacitou. Kapacita jednej kazety sa bežne pohybuje v <em>stovkách GB</em> a kazetovo-páskové pamäte sa typicky používajú ako veľkokapacitné archívne pamäte.</p><p>Nevýhodou kazetovo-páskových pamätí je <em>nízka záznamová rýchlosť</em> a najmä <em>sériový prístup k údajom,</em> ktorý tieto pamäte vylučuje z bežného použitia počas normálnej prevádzky počítača.</p><h4>4.3.6.4 CD-ROM pamäte</h4><p>Médium <em>CD-ROM pamäte</em> je rovnako ako disketa <em>výmenné.</em> Na základnej podložke je nanesená <em>odrazová (reflexná) vrstva</em> z hliníka, ktorá je prekrytá <em>maskovacou vrstvou (land).</em> Na tejto sa nachádza vrchná priehľadná <em>ochranná vrstva.</em> Informácie sú zaznamenané pomocou <em>jamiek (pits)</em> v maskovacej vrstve. Pri čítaní informácie laserový lúč šírky asi <em>1,6 nm</em> sleduje <em>stopu</em> na médiu. V prípade, ak je v maskovacej vrstve jamka, lúč sa odrazí a je prijatý <em>optickým snímačom.</em> Ide o bezkontaktné snímanie, takže ani médium, ani snímač sa neopotrebúvajú.</p><p>Médium sa vkladá do <em>mechaniky CD-ROM.</em> Pôvodne sa <em>CD (Kompaktný disk - Compact Disc)</em> používal pre záznam zvuku a až potom sa stal veľkokapacitným nosičom údajov vo výpočtovej technike. V súčasnosti sa používa ako inštalačné médium veľkých softvérových produktov, na archiváciu údajov a v <em>multimediálnych</em> aplikáciách na uloženie textu, digitalizovaného zvuku a obrazu.<br />Okrem médií <em>CD-ROM,</em> na ktorých je informácia zaznamenaná priamo u výrobcu, existujú jedenkrát programovateľné médiá <em>CD-R (CD-Recordable)</em> a viackrát prepisovateľné <em>magneticko-optické disky,</em> ktoré si môže naprogramovať používateľ vlastnými údajmi v špeciálnych mechanikách. Na čítanie obidvoch uvedených <em>CD</em> nosičov je pritom možné použiť štandardné <em>CD-ROM</em> mechaniky.</p><p><strong>Organizácia údajov</strong></p><p>Na <em>CD,</em> ktorý má štandardný priemer <em>12 cm,</em> sa nachádza <em>jediná špirálovitá stopa</em> dĺžky zhruba <em>5 km,</em> ktorá má asi <em>20 000</em> závitov.</p><p>Organizácia údajov na <em>Audio-CD</em> a <em>CD-ROM</em> je prakticky rovnaká. Uložené údaje je možné prehrávať asi <em>1 hodinu = 60 minút.</em> Každá minúta záznamu sa delí na <em>60 sekúnd,</em> každá sekunda má <em>75 blokov,</em> očíslovaných <em>0</em> až <em>74.</em> Každý blok má <em>2352 bajtov.</em> Kým pri <em>Audio-CD</em> je celá táto kapacita venovaná údajom, pri <em>CD-ROM (Mód 1)</em> je pre údaje v bloku venovaných iba <em>2048 bajtov</em> a zvyšok slúži na synchronizáciu a opravy chýb.</p><p><strong>Výpočet kapacity CD-ROM</strong></p><p>Kapacitu CD-ROM vypočítame ako súčin:</p><p><em>(celkový počet sekúnd).(počet blokov).(počet bajtov na blok)</em></p><p>Pri uvedených parametroch je kapacita viac ako <em>600 MB.</em></p><h2>4.4 Vstupno/výstupný podsystém počítača</h2><em>Vstupno/výstupný podsystém počítača </em>slúži na vstup, resp. na výstup údajov. Musí umožniť komunikáciu procesora s rôznymi<em> vstupnými a výstupnými (periférnymi) zariadeniami</em>, napr. typickým vstupným zariadením je<em> klávesnica</em>, typickým výstupným zariadením <em>monitor </em>alebo <em>tlačiareň</em>. Niektoré periférne zariadenia slúžia na vstup aj výstup údajov, napr.<em> pevné disky</em>.<br /><h3>4.4.1 Pripojenie periférnych zariadení k zbernici počítača</h3><p>Periférnych zariadení, podobne ako pamäťových obvodov, môže byť k zbernici počítača pripojených niekoľko. Z toho vyplýva, že procesor musí byť schopný rozlíšiť, s ktorým periférnym zariadením bude pracovať. Pri vlastnej práci s periférnym zariadením nesmie prísť ku konfliktom, či už s pamäťou, alebo s inými periférnymi zariadeniami.<br />Na obr. 4.24 je naznačené principiálne pripojenie periférnych zariadení k zbernici počítača.<br />Ako z obrázku vidíme, periférne zariadenia <em>(PERIF1 ... PERIFn)</em> sú pripojené k zbernici prostredníctvom svojich<em> adaptérov (ADAPT1 až ADAPTn)</em>.<br />Dekóder <em>DEC2</em>na základe aktuálnej adresy na adresovej zbernici počítača určuje, s ktorým adaptérom sa práve pracuje. Jeho úloha je podobná, ako úloha dekódera z obr. 4.18 - vyberá práve jeden aktívny adaptér, čím zabraňuje vzájomným konfliktom adaptérov na údajovej zbernici. Pripojenie adresy k adaptérom je naznačené čiarkované - využíva sa iba v prípade, ak adaptér obsahuje <em>viacero interných registrov </em>na výber práve jediného registra, s ktorým sa pracuje.<br />Vylúčenie konfliktov medzi adaptérmi a pamäťou je zabezpečené tým, že adaptéry a pamäťové obvody majú<em> vlastné riadiace signály</em>, ktoré nikdy nie sú aktívne súčasne. Pamäťové obvody používajú na zápis resp. čítanie signály <em>MEMW#</em> resp.<em> MEMR#</em>, adaptéry používajú signály<em> lOW# a IOR#</em>.<br /></p><p align="center"><img src="../files/obrazky/44.png" border="0" alt="obr44" width="568" height="400" /></p><p align="center">OBR. 4.24. Pripojenie periférnych zariadení k zbernici počítača<br /></p><h3>4.4.2 Komunikácia procesora s adaptérom periférneho zariadenia</h3><em>Adaptér</em> vytvára nevyhnutné <em>rozhranie </em>medzi zbernicou počítača a periférnym zariadením, pretože priame pripojenie periférneho zariadenia na zbernicu počítača vo všeobecnosti nie je možné (odlišné napäťové úrovne, výkonové požiadavky, spôsob činnosti, spôsob prenosu údajov, bezpečnosť atď.).<br />Adaptér môže byť jednoduchý (napr. na pripojenie signalizačného prvku nám môže stačiť Obyčajný<em> register</em>), ale môže to byť aj značne zložitý obvod (napr. <em>videoadaptér </em>na pripojenie <em>grafického monitora</em>).<br />Adaptéry sú obyčajne<em> programovateľné</em>, takže procesor pred vlastným prenosom údajov vyšle najprv do adaptéra <em>riadiace slová </em>a z adaptéra okrem údajov môže načítať<em> stavové slová</em>. Treba si preto uvedomiť, že nie každý zápis/čítanie do/z adaptéra znamená zápis alebo čítanie z pripojeného periférneho zariadenia.<br /><em>Rozhranie </em>je vo veľkej väčšine prípadov v súčasnosti<em> štandardizované</em>, čo umožňuje k počítaču pripojiť periférne zariadenia od ľubovoľného výrobcu, ktorý toto rozhranie rešpektuje.<br /><em>Neštandardné rozhrania </em>sa obyčajne vytvárajú pri použití počítača na špeciálne aplikácie, napr. <em>na riadenie technologických procesov, vo vnorených systémoch </em>a pod.<br /><strong>Komunikácia procesora s adaptérom na najnižšej úrovni</strong><br /><em>Čítanie z adaptéra</em>. Procesor musí vyslať na adresovú zbernicu adresu adaptéra, z ktorého chce načítať informáciu a nastaviť aktívnu úroveň signálu pre čítanie<em> IOR#</em>. Aktívna úroveň signálu musí trvať dostatočne dlhý čas. Po istom čase (doba prístupu) adaptér vyšle na údajovú zbernicu platnú informáciu.<br /><em>Zápis do adaptéra</em>. Procesor musí vyslať na adresovú zbernicu adresu adaptéra, do ktorého chce zapísať a na údajovú zbernicu vyslať platné údaje. Potom môže nastaviť do aktívnej úrovne signál pre zápis<em> IOW#</em>. Je potrebné dodržať jednak istú minimálnu dobu trvania tohto signálu, ako aj dostatočný predstih a presah údajov voči tomuto signálu. Na obr. 4.25 sú nakreslené typické signálové sledy pre cyklus čítania a zápisu z/do adaptéra periférneho zariadenia (<em> PZ</em>).<br /><h3>4.4.3 Štandardné rozhrania na pripojenie periférnych zariadení</h3><p>Pre štandardné rozhranie sú definované<em> použité napäťové úrovne, konektory, spôsob prenosu, protokoly</em>, atď. V ďalšom sa budeme stručne zaoberať dvoma typickými štandardnými rozhraniami - paralelným rozhraním <em>CENTRONICS </em>a sériovým rozhraním<em> RS232C</em>. </p><p align="center"><img src="../files/obrazky/45.png" border="0" alt="obr45" width="484" height="399" /></p><p align="center">OBR. 4.25. Signálové sledy pre čítanie a zápis z/do adaptéra PZ<br /></p><h4>4.4.3.1 Paralelné rozhranie CENTRONICS</h4><p>Rozhranie <em>CENTRONICS </em>je štandardné<em> paralelné rozhranie</em>. Šírka prenášaných údajov je<em>8bitov</em>. Okrem prenosu údajov medzi <em>vysielačom </em>(adaptérom) a <em>prijímačom </em>(periférnym zariadením) sa pri komunikácii používajú aj<em> riadiace signály</em>. Tieto slúžia na vzájomnú <em>synchronizáciu </em>vysielača a prijímača.<br />Rozhranie <em>CENTRONICS </em>sa typicky používa pre pripojenie<em> tlačiarní</em>.<br />Na obr. 4.26 je nakreslený principiálny signálny sled prenosu jednej slabiky prostredníctvom rozhrania<em> CENTRONICS</em>. Vyznačené sú aj minimálne doby trvania, predstihu a presahu jednotlivých signálov.</p><p>&#160;</p><div align="center"><img src="../files/obrazky/46.png" border="0" alt="obr46" width="464" height="217" /><br />OBR. 4.26. Prenos jednej slabiky cez rozhranie CENTRONICS</div><p><em>Vysielač </em>vyšle na údajové vodiče (<em> DATAO-7</em>) slabiku, ktorú chce preniesť do prijímača a vygeneruje impulz definovanej dĺžky<em> STB# (STROBE - navzorkovanie údajov)</em>. Týmto impulzom sa vysielané údaje zapíšu do záchytného registra v prijímači.<br /><em>Prijímač </em>reaguje takým spôsobom, že nastaví do aktívnej úrovne signál<em> BUSY (Obsadenosť prijímača)</em>, ktorým oznamuje vysielaču, že je zamestnaný spracúvaním prijatého údaja a nieje schopný prijať ďalší údaj. Keď prijatý údaj prijímač spracuje (napr. tlačiareň vytlačila prijatý znak), vráti signál <em>BUSY </em>do neaktívnej úrovne a potvrdí prenos vygenerovaním impulzu definovanej dĺžky<em> ACK# (Acknowledge - potvrdenie)</em>. Až potom môže nasledovať prenos ďalšej slabiky.<br />Použité napäťové úrovne všetkých signálov sú úrovne<em> TTL</em>, čím je daná nevyhnutnosť krátkej vzdialenosti medzi vysielačom a prijímačom (rádovo<em> jednotky metrov</em>).<br /></p><h4>4.4.3.2 Sériové rozhranie RS232C </h4><p>Rozhranie <em>RS232C </em>je štandardné<em> sériové rozhranie</em>. Údaje sa medzi vysielačom a prijímačom prenášajú v sériovom tvare ako <em>postupnosť bitov </em>po jedinom vodiči. Pretože po zbernici počítača sa údaje prenášajú v paralelnom tvare, adaptér musí realizovať pri vysielaní z počítača prevod údajov z paralelného na sériový tvar a pri príjme prevod údajov zo sériového na paralelný tvar. Na synchronizáciu vysielača a prijímača sú opäť použité riadiace signály. Používajú sa dva typy prenosu -<em> synchrónny a asynchrónny</em>.<br />Pri <em>synchrónnom prenose </em>sa každý prenášaný bit<em> vzorkuje špeciálnym hodinovým impulzom</em>, slabiky sa prenášajú <em>bez prerušenia </em>jedna za druhou a nevykonáva sa žiadna kontrola správnosti prenosu na úrovni slabiky.<br />Pri <em>asynchrónnom prenose </em>sa po údajovom vodiči okrem údajových bitov prenášajú aj <em>špeciálne bity</em>, ako sú<em> štart-bit</em>,<em> paritný bit</em> a<em> stop-bit</em>. Rýchlosť prenosu je štandardizovaná (napr.<em>1200, 2400, 4800, 9600, 19200 bit/s</em>), takže prenos každého bitu trvá presne určený časový okamih. Neaktívna úroveň na údajovom vodiči je<em> log. 1</em>.<br />Prenos slabiky je odštartovaný<em> štart-bitom</em>, ktorý začína zmenou z <em>log. 1</em>do <em>log. 0</em>a úroveň <em>log.0 </em>potom trvá dobu prenosu jedného bitu. Potom nasledujú<em> údajové bity</em>, najskôr<em> nultý bit</em>, potom <em>prvý bit </em>atď. Používa sa <em>7</em> alebo <em>8</em> údajových bitov. Za posledným údajovým bitom nasleduje<em> paritný bit</em>, a to buď pre <em>párnu </em>alebo <em>nepárnu </em>paritu. <em>Párna parita </em>znamená, že vysielač doplní paritným bitom počet jednotiek v slabike<em> na párny</em>, pri <em>nepárnej parite </em>na<em> nepárny</em>. Prijímač po prijatí údajovej slabiky nezávisle určí paritu tejto slabiky a porovná ju s prijatým paritným bitom. Paritný bit je voliteľný, ak chceme kontrolovať správnosť prenosu už na úrovni jednotlivých slabík.<br />Prenos slabiky je ukončený<em> stop-bitom</em>, čo je vlastne <em>podržanie úrovne log.l </em>na údajovom vodiči na dobu prenosu jedného bitu. Používa sa<em> jeden</em>,<em> jeden a pol</em> alebo <em>dva </em>stop-bity. Až za stop-bitom môže nasledovať prenos ďalšej slabiky, t.j. nový<em> štart-bit</em>.<br />Na obr. 4.27 je naznačený prenos slabiky<em>11001010</em>, ak je použitá párna parita a jeden stop-bit. Štart-bit je označený<em> S</em>, paritný bit <em>P </em>a stop-bit<em> T</em>. Pretože máme párnu paritu, paritný bit je nulový (prenášaná slabika má párny počet jednotkových bitov).</p><p align="center"><img src="../files/obrazky/47.png" border="0" alt="obr47" width="444" height="43" /><br />OBR. 4.27. Prenos jednej slabiky pri asynchrónnom prenose</p><p>Vzájomné prepojenie vysielača a prijímača je nakreslené na obr. 4.28a. Pre ich synchronizáciu pri asychrónnom prenose sú použité špeciálne riadiace signály.</p><p align="center"><img src="../files/obrazky/48.png" border="0" alt="obr48" width="501" height="274" /> <br /></p><div align="center">OBR. 4.28. Prepojenie vysielača a prijímača rozhraním RS232C<br /></div><p>Signál <em>TxD (Transmit Data - vysielané údaje)</em>vysielača je pripojený na signál <em>RxD (Receive Data - prijímané údaje)</em>prijímača. Prijímač žiada vysielač o vyslanie údajov signálom<em> RTS (Request To Send - výzva k vysielaniu)</em>, ktorý je pripojený na signál <em>CTS (Clear To Send)</em> vysielača. Vysielač oznamuje svoju pripravenosť k prenosu signálom<em> DTR (Data Terminál Ready)</em>, ktorý je pripojený na signál <em>DSR (Data SetReady)</em>prijímača<br />Prenos sa uskutoční iba vtedy, ak je vysielač aj prijímač pripravený. Tým je zabezpečené, že žiadne údaje sa počas prenosu nestratia (napr. ak prijímač nestíha spracovať údaje tak rýchlo za sebou, ako ich je schopný vysielač vysielať, jednoducho po prijatí údaja prestane žiadať ďalší údaj a vysielač musí čakať).<br />Uvedený spôsob prepojenia sa používa pri<em> simplexnom prenose</em>, kedy je jednoznačne určené, kto je vysielačom a kto prijímačom a toto usporiadanie nie je možné zmeniť. Rozhranie <em>RS232C </em>však býva často realizované ako<em> obojsmerné</em>, t.j. zariadenie môže údaje nielen vysielať, ale aj prijímať. Samozrejme, potom obsahuje všetky signály vysielača aj prijímača. Ak sú navzájom prepojené dve takéto zariadenia, je možné vykonávať dva spôsoby prenosu - <em>poloduplexný (halfduplex)</em>a <em>duplexný (full duplex, plný duplex)</em>prenos.<br /><em>Poloduplexný prenos </em>sa vyznačuje tým, že každé zariadenie môže tak vysielať, ako aj prijímať údaje, ale nie naraz - v istom časovom úseku jedno zariadenie pracuje ako vysielač a druhé ako prijímač, v inom časovom úseku tomu môže byť naopak.<br /><em>Duplexný prenos </em>sa vyznačuje tým, že zariadenie môže naraz pracovať aj ako vysielač, aj ako prijímač. Na obr.4.28 b je nakreslené prepojenie pri duplexnom prenose.<br />Napäťové úrovne rozhrania <em>RS232C </em>nie sú úrovne<em> TTL</em>, ale používa sa napätie <em>oboch polarít</em> a<em> väčších hodnôt</em>. Adaptér teda musí obsahovať<em> prevodník napäťových úrovní</em>. Úrovni <em>log.0 </em>zodpovedá napätie z intervalu &lt;+3 V; + 15 V&gt;, úrovni <em>log.1</em>napätie z intervalu &lt;-3 V; -15 V&gt;. Z tohto dôvodu je možné prepojiť vysielač a prijímač na väčšie vzdialenosti <em>(15 až 20 m)</em>.<br /></p><h3>4.4.4 Spojenie počítača s technologickým prostredím</h3>V prípade, že sa počítač používa na riadiacu aplikáciu alebo je súčasťou vnoreného systému, je priamo spojený s technologickým prostredím. Výstupné periférne zariadenia sú v tomto prípade<em> akčné členy (Actuators)</em>, vstupné periférne zariadenia sú<em> senzory (Sensors)</em>. Prostredníctvom akčných členov počítač <em>vstupuje </em>do prostredia, prostredníctvom senzorov <em>načítava stavové informácie </em>z prostredia. Niekedy počítač obsahuje iba senzory (napr. ak je použitý na zber údajov na ďalšie spracovanie), inokedy iba akčné členy (riadenie<em> bez spätnej väzby)</em>. Iba v prípade, ak počítač obsahuje akčné členy spolu so senzormi, je možné vykonávať<em> riadenie so spätnou väzbou</em>, ktoré sa vyznačuje tým, že počítač môže na základe stavovej informácie sledovať výsledok svojho riadiaceho zásahu a korigovať ho.<br /><h4>4.4.4.1 Vstup a výstup logických a číslicových signálov</h4>Ako <em>logický signál </em>budeme označovať signál, ktorý nesie iba<em> dvojstavovú informáciu</em>, takže na jeho prenos stačí<em> jednobitový kanál</em>.<br /><em>Číslicový signál </em>nesie<em> viacstavovú informáciu</em>, takže na jeho paralelný prenos je nutné použiť <em>viacbitový kanál</em>. Počet stavov, ktoré je možné zakódovať do<em> n-bitov</em>, je 2<sup>n</sup>.<br />Realizovať samostatný adaptér na prenos každého logického signálu je veľmi neefektívne, preto sa logické signály združujú do skupín, ktoré prenáša jeden adaptér. Ak máme <em>n-bitový</em> adaptér, môžeme ním prenášať <em>n </em>logických signálov. Rovnakým adaptérom je potom možné prenášať <em>n-bitový </em>číslicový signál. Z tohto dôvodu budeme preto v ďalšom hovoriť už iba o prenose číslicových signálov.<br />Kvôli jednoduchosti budeme predpokladať, že senzor má na svojom (číslicovom) výstupe, ktorý je pripojený na vstup adaptéra, signály o úrovni<em> TTL</em>. Podobne nech aj akčný člen vyžaduje pre svoje ovládanie signály o úrovni<em> TTL</em>.<br /><strong>Vstup číslicových signálov</strong><br />V prípade, ak je šírka slova senzora <em>menšia </em>alebo<em> rovnaká</em>, ako šírka údajovej zbernice počítača, adaptér môže byť veľmi jednoducho realizovaný<em> oddeľovačom s trojstavovým výstupom</em>.<br />Na vstup oddeľovača budú pripojené výstupy zo senzora, výstup adaptéra bude pripojený na údajovú zbernicu počítača.<br />Ak sa výstup zo senzora môže počas načítavania zmeniť, vhodnejšie je použiť <em>záchytný register </em>a načítanie riešiť v dvoch krokoch. V prvom kroku procesor najprv navzorkuje hodnotu zo senzora do registra a v druhom kroku načíta z registra platný údaj.<br />Ak je šírka slova senzora <em>väčšia </em>ako šírka údajovej zbernice počítača, adaptér je potrebné realizovať viacerými registrami<em> so spoločným vzorkovaním</em>. Procesor potom v prvom kroku navzorkuje celý údaj zo senzora do týchto registrov a v ďalších krokoch z nich postupne načíta platné údaje.<br /><strong>Výstup číslicových signálov</strong><br />Ak je šírka slova akčného člena <em>menšia </em>alebo<em> rovnaká</em>, ako šírka údajovej zbernice počítača, adaptér môže byť veľmi jednoducho realizovaný prostredníctvom<em> registra</em>. Výstupy registra sú pripojené priamo na vstup akčného člena.<br />Ak je šírka slova akčného člena <em>väčšia </em>ako šírka údajovej zbernice počítača, adaptér je potrebné realizovať viacerými registrami<em> so spoločným ovládaním výstupu</em>. Procesor najskôr požadovaný údaj postupne zapíše do všetkých registrov a potom uvoľní spoločný výstup registrov, čím sa celé slovo pripojí k akčnému členu naraz.<br /><h4>4.4.4.2 Vstup a výstup analógových signálov</h4><p>Priame spracovanie analógových hodnôt v číslicovom počítači nieje možné, pretože číslicový počítač vie pracovať iba s číslicovými premennými. Analógové údaje je preto potrebné transformovať na číslicové.<br />Pretože hodnota analógového údaja sa v čase mení, treba si uvedomiť, že číslicový počítač bude pracovať iba s<em> okamžitými hodnotami analógových údajov</em>, t.j. hodnotami, ktoré získal v istých bodoch<em> diskrétneho času</em>. Týmto hodnotám hovoríme<em> vzorky</em>.<br />Pre vstup analógových údajov do číslicového počítača sú realizované<em> analógovo/číslicové (A/D) prevodníky</em>, pre výstup analógových údajov z počítača<em> číslicovo/analógové (D/A) prevodníky</em>.<br /><strong>Analógovo/číslicové prevodníky</strong><br />Na ilustráciu uvedieme dva typické <em>A/D </em>prevodníky - <em>prevodník s postupným prevodom </em>a <em>paralelný prevodník</em>.<br /><u>Prevodník s postupným prevodom</u><br /><em>Prevodník s postupným prevodom </em>sa vyznačuje tým, že prevod analógového údaja na číslicový sa vykonáva v niekoľkých krokoch.<br />Na obr. 4.29 je bloková schéma A/D prevodníka s postupným prevodom.</p><div align="center"><img src="../files/obrazky/49.png" border="0" alt="obr49" width="430" height="158" /><br />OBR. 4.29. A/D prevodník s postupným prevodom</div><p><em>u(t)</em>- hodnota vstupnej analógovaj veličiny (v našom prípade<em> napätie</em>). Kvôli jednoduchosti predpokladajme, že počas prevodu sa táto hodnota nemení. Nech všetky hodnoty<em> u(t) &gt; 0</em>.<br /><em>u<sub>da</sub> </em>- výstupné napätie D/A prevodníka.<br /><em>DATA </em>- vzorka, získaná konkrétnym prevodom.<br />Používajú sa dve základné metódy prevodu:<br /><em>Metóda postupných prírastkov </em>sa vyznačuje tým, že vyhodnocovací obvod začína od <em>najnižšej hodnoty </em>(v našom prípade číslo<em>0</em>) a postupne po <em>najnižšom prírastku</em> (pripočítava číslo<em> J</em>) zvyšuje hodnotu<em> DATA</em>. Komparátor porovnáva veľkosť vstupného napätia <em>u(t)</em>s napätím <em>u<sub>da</sub></em>, ktoré sa získalo číslicovo/analógovým prevodom číslicového údaja<em> DATA</em>. V okamihu, keď <em>u<sub>da</sub> <u>&lt;</u> u(t)</em> (signál <em>GTE </em>nadobudne aktívnu úroveň), je prevod ukončený a hodnota <em>DATA </em>reprezentuje<em> číslicovú hodnotu vstupného napätia</em>. Výhodou tejto metódy je jednoduchý vyhodnocovací obvod, nevýhodou je to, že ak máme <em>n-bitový </em>prevodník, prevod sa môže v najnepriaznivejšom prípade skladať až z 2&quot; krokov.<br /><em>Metóda postupnej aproximácie </em>pracuje takým spôsobom, že vyhodnocovací obvod začína od<em> najvyššieho bitu</em>, ktorý nastaví na 7 a kontroluje sa výstup komparátora. V prípade, ak je signál <em>GTE </em>aktívny, vyhodnocovací obvod vráti hodnotu tohto bitu na<em>0</em>. Ak je signál <em>GTE </em>neaktívny, hodnota bitu sa ponechá<em>1</em>. Vyhodnocovací obvod potom nastaví ďalší bit v poradí na<em>1</em>, otestuje signál <em>GTE </em>atď. Po <em>n </em>krokoch je prevod ukončený.<br /><u>Paralelný A/D prevodník </u><br /><em>Paralelný A/D prevodník </em>sa vyznačuje tým, že prevod sa vykoná v jedinom kroku. Tento prevodník je najrýchlejší. Jeho bloková schéma je na obr. 4.30. Nevýhodou tohto prevodníka je jeho zložitá realizácia - n-bitový prevodník obsahuje 2<sup> n</sup> komparátorov. Vyhodnocovací obvod slúži iba na prevod z jedného kódu do druhého.<br /><strong>Číslicovo/analógové prevodníky</strong><br />Na ilustráciu uvedieme jednoduchý<em> D/A prevodník s váhovými odpormi</em>. Jeho bloková schéma je na obr. 4.31. </p><p align="center"><img src="../files/obrazky/50.png" border="0" alt="obr50" width="449" height="474" /> <br /></p><p align="center">OBR. 4.30. Paralelný A/D prevodník </p><p>Princíp činnosti prevodníka s váhovými odpormi vidno priamo z obrázku. Prevodník <em>I/U</em> transformuje celkový výstupný prúd<em> I</em>, ktorý je daný súčtom jednotlivých čiastkových prúdov, na výstupné analógové napätie<em> U</em>.<br />Okrem prevodníka s váhovými odpormi sa často používa aj<em> D/A prevodník s impulznou štrkovou moduláciou (PWM)</em>.</p><p align="center"><img src="../files/obrazky/51.png" border="0" alt="obr51" width="583" height="264" /> <br /></p><p align="center">OBR. 4.31. D/A prevodník s váhovými odpormi </p><h4>4.4.4.3 Galvanické oddelenie</h4><p>Doteraz sme implicitne predpokladali, že počítač je<em> galvanický (vodivo) spojený s prostredím</em>. V niektorých prípadoch však takéto riešenie nevyhovuje:<br /><em>Rušivé vplyvy prostredia na činnosť počítača alebo na komunikáciu</em>. Elektromagnetické rušenie môže spôsobovať problémy pre správnu činnosť počítača alebo pri komunikácii počítača so vzdialenými zariadeniami.<br /><em>Možnosť ohrozenia obsluhy alebo zničenia počítača zo strany prostredia</em>. V prípade poruchy v prostredí môže byť priamo k počítaču pripojené nebezpečné (napr. sieťové) napätie, ktoré spôsobí zničenie počítača alebo úraz obsluhy.<br /><em>Možnosť ohrozenia prostredia zo strany počítača</em>. V prípade poruchy v počítači (napr. zničenie napájacieho zdroja) môže byť k prostrediu pripojené sieťové napätie, ktoré môže zničiť riadené zariadenie alebo spôsobiť úraz.<br />Všetky uvedené problémy je možné riešiť <em>galvanickým oddelením </em>počítača od prostredia, čo znamená, že počítač už s prostredím nebude vodivo spojený. Samozrejme, oddeľovacie prvky musia byť dostatočne napäťovo a výkonovo dimenzované.<br />V súčasnosti sa na galvanické oddelenie používajú <em>elektronické prvky (optočleny)</em>a <em>elektromechanické prvky (relé, stýkače)</em>.<br />Na obr. 4.32 je nakreslená principiálna schéma galvanického oddelenia vstupného a výstupného logického signálu počítača od prostredia optočlenom. V prípade číslicového signálu musí byť realizované<em> samostatné oddelenie pre každý bit</em>.</p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/52.png" border="0" alt="52" width="449" height="405" /></div><br /><p>&#160;</p><div align="center">OBR. 4.32. Principiálna schéma galvanického oddelenia optočlenom </div><p>&#160;</p><p><em>Zabezpečenie samotného počítača proti rušivým vplyvom prostredia a naopak </em>predstavuje samostatnú a rozsiahlu problematiku<em> elektromagnetickej kompatibility číslicových zariadení</em>, ktorá už presahuje rámec tejto publikácie. </p><h3>4.4.5 Metódy vstupno/výstupných prenosov</h3>Pod <em>vstupno/výstupným (V/V) prenosom </em>rozumieme prenos údajov medzi periférnym zariadením a procesorom alebo medzi periférnym zariadením a pamäťou.<br /><strong>Riadenie zbernice počítača počas počas V/V prenosu</strong> Podľa toho, <em>kto riadi zbernicu počítača počas prenosu </em>údajov z/do periférneho zariadenia, rozdeľujeme V/V prenosy na<em> prenosy s účasťou procesora &amp; prenosy bez účasti procesora</em>. <h4>4.4.5.1 Prenosy s účasťou procesora</h4><p>Pri V/V prenosoch s účasťou procesora generuje riadiace signály zbernice procesor. Týmto spôsobom sa typicky vykonáva prenos <em>jednotlivých údajov </em>a údaje sa prenášajú<em> medzi procesorom a V/V zariadením</em>.<br />Vykonať prenos údajov z/do periférneho zariadenia nemusí byť možné v každom okamihu (zariadenie je schopné prijať/vyslať údaj iba v istom čase a istou rýchlosťou). Podľa toho, <em>akým spôsobom sa rozhodne o okamihu odštartovania prenosu údajov</em>, rozlišujeme tieto V/V prenosy:<br /><em>Nepodmienený V/V prenos </em>sa vyznačuje tým, že procesor implicitne považuje V/V zariadenie v ktoromkoľvek okamihu<em> pripravené na prenos</em>, t. j. že kedykoľvek môže zo vstupného zariadenia údaj načítať a do výstupného zariadenia kedykoľvek údaj zapísať. Prenos je veľmi rýchly, pretože sa vykoná pracovnou rýchlosťou procesora. Na druhej strane, iba málo periférnych zariadení je schopných prenos takouto rýchlosťou uskutočniť. Typicky sa tento spôsob používa iba na <em>ovládanie indikačných prvkov, načítanie stavových slov </em>zariadenia a pod.<br />Na obr. 4.33 je nakreslené pripojenie jednoduchého vstupného periférneho zariadenia k zbernici počítača. Toto zariadenie sa skladá z 8 tlačidiel. </p><div style="text-align: center"><img src="../files/obrazky/53.png" border="0" alt="53" width="561" height="360" /></div><p>&#160;</p><p>&#160;</p><div align="center">OBR. 4.33. Vstupné periférne zariadenie s nepodmieneným prenosom </div><p>&#160;</p><p>Adaptér je vytvorený trojstavovým oddeľovacím obvodom<em> BUF1</em>. Na vstup tohto obvodu sú pripojené jednotlivé tlačidlá, výstupy obvodu sú pripojené na zbernicu počítača. Výstupy sú aktivované iba v prípade, ak je na adresovej zbernici nastavená adresa <em>300H</em> (signál <em>SEL0# </em>z dekódera periférnych zariadení má vtedy aktívnu úroveň) a súčasne je aktívny signál <em>IOR#</em> (vykonáva sa cyklus čítania zo vstupného zariadenia). Konkrétna adresa <em>300H</em> je zvolená iba pre ilustráciu nášho príkladu.<br />Vstupy obvodu <em>BUF1</em>sú ošetrené odpormi, pripojenými druhým koncom na napájacie napätie, čím je zabezpečená úroveň <em>log. 1</em>na vstupe obvodu v prípade, ak tlačidlo nie je stlačené.<br />Nasledujúci úsek programu v jazyku symbolických inštrukcií procesorov rodiny <em>80x86</em> zisťuje, ktoré tlačidlá sú stlačené:<br /><br />MOV DX, 300H ; Adresa adaptéra do registra DX<br />IN AL, DX ; Načítanie vstupného údaja z adaptéra, adresa ktorého je v registri<br />; DX, do registra AL. Načíta sa boolovský vektor, hodnota jedno-<br />; tlivých bitov záleží od toho, či je tlačidlo stlačené (log.O) alebo<br />; nestlačené (log. 1)<br /><br /><em>Netestovali sme pripravenosť tlačidiel</em>, pretože implicitne sme predpokladali, že v tom okamihu, kedy čítame vstupný údaj, sú pripravené na prenos. Je zrejmé, že môže nastať aj situácia, kedy žiadne z tlačidiel nie je stlačené, ale údaj sa napriek tomu načíta (hodnota <em>OFFH</em>).<br />Pri <em>podmienenom V/V prenose </em>procesor pred vlastným vykonaním prenosu údajov najskôr testuje <em>pripravenosť </em>zariadenia prijať, resp. vyslať údaje. Procesor zisťuje pripravenosť takým spôsobom, že z adaptéra načíta<em> stavové slovo</em>, v ktorom jeden alebo niekoľko bitov nesie<em> informáciu o pripravenosti zariadenia</em>. Len v prípade, ak je zariadenie k prenosu pripravené, procesor vykoná vlastný prenos údajov. Tento prenos rešpektuje pracovnú rýchlosť zariadenia, jeho nevýhodou je však to, že v prípade pomalého periférneho zariadenia (napr. tlačiareň) procesor strávi podstatne viac času čakaním, ako vlastným prenosom údajov.<br />Na obr. 54 je nakreslené upravené zapojenie z obr. 4.33. V tomto prípade chceme vykonať prenos iba v tom prípade, keď je niektoré tlačidlo stlačené. Procesor bude čakať dovtedy, kým nezistí pripravenosť zariadenia k prenosu, t.j. stlačenie niektorého tlačidla. </p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/54.png" border="0" alt="54" width="561" height="490" /></div><br /><p>&#160;</p><p align="center">OBR. 4.34. Upravené zapojenie pre podmienený prenos </p><p>&#160;</p><p>Vidíme, že do adaptéra je pridaný ďalší oddeľovací obvod<em> BUF2</em>, na vstup ktorého je pripojený signál<em> KEY</em>, indikujúci stlačenie niektorého tlačidla. Výstup obvodu je pripojený na <em>bit 0</em>údajovej zbernice. Prostredníctvom tohto obvodu sa načíta<em> stavové slovo</em>.<br />Obvod <em>BUF2</em>je aktivovaný adresou <em>320H (signál SELltt má vtedy aktívnu úroveň)</em> a aktívnou úrovňou signálu <em>IOR# </em>(vykonáva sa cyklus čítania zo vstupného zariadenia). Signál <em>KEY </em>je vtedy pripojený na <em>bit 0</em>údajovej zbernice počítača. Konkrétna adresa <em>320H</em> je zvolená iba pre účely ilustrácie príkladu.<br />Nasledujúci úsek programu v jazyku symbolických inštrukcií procesorov rodiny <em>80x86</em> vykoná načítanie údaja iba v prípade, ak je niektoré tlačidlo stlačené:<br /><br />MOV DX, 320H ; adresa oddeľovača stavového signálu KEY do registra DX<br />NAVI: ; návestie<br />IN AL, DX<br />TEST AL,1<br />JZ NAVI<br />MOV DX, 300H<br />IN AL, DX<br />; načítanie stavového slova do registra AL<br />; otestovanie hodnoty bitu 0 (signál KEY)<br />; ak je hodnota tohto bitu log.O, nieje žiadne tlačidlo stlačené,<br />; skok sa vykoná a pokračuje sa inštrukciou na návestí NAVI, t.j.<br />; opätovné načítanie stavového slova<br />; ak je hodnota tohto bitu log. J, niektoré tlačidlo je stlačené,<br />; skok sa nevykoná a pokračuje sa nasledujúcou inštrukciou<br />; už známy nepodmienený prenos z predchádzajúceho príkladu<br /><br />Z programu vidíme, že procesor bude čakať dovtedy, kým nebude niektoré tlačidlo stlačené. Počas čakania nevykonáva žiadnu užitočnú činnosť.<br />Nevýhody podmieneného prenosu odstraňuje<em> V/V prenos s prerušením</em>. Pri takomto spôsobe prenosu procesor netestuje pred prenosom údajov pripravenosť V/V zariadenia. V/V zariadenie totiž v prípade svojej pripravenosti k prenosu vygeneruje<em> žiadosť o prerušenie</em>. Procesor preruší práve prebiehajúci program a v rámci obslužného programu prerušenia bez otestovania pripravenosti zariadenia vykoná vlastný prenos údajov. Po jeho skončení pokračuje v prerušenom programe. Keď je periférne zariadenie schopné prijať/vyslať ďalší údaj, opäť vygeneruje novú žiadosť o prerušenie atď. Čas, ktorý pri podmienenom prenose procesor strávil neefektívnym čakaním, je pri prenose s prerušením využitý na užitočný výpočet.<br />Aby sme mohli použiť <em>V/Vprenos s prerušením </em>pre periférne zariadenie z obr. 4.34, signál <em>KEY</em> pripojíme na<em> prerušovací vstup procesora</em>. Oddeľovač <em>BUF2</em>teraz nie je potrebný, pretože pripravenosť zariadenia k prenosu nebudeme testovať.<br />Obslužný podprogram prerušenia môže vyzerať takto:<br /><br />OBSLUHA:<br />PUSH AX ; odloženie obsahu registra AX do zásobníka<br />PUSH DX ; odloženie obsahu registra DX do zásobníka<br />MOV DX, 300H ; už známy nepodmienený prenos<br />IN AL,DX<br />MOV UDAJ, AL ; odloženie načítaného údaja z registra AL do premennej UDAJ<br />POP DX ; obnovenie obsahu registra DX zo zásobníka<br />POP AX ; obnovenie obsahu registra AX zo zásobníka<br />IRET ; návrat do prerušeného programu<br /><br /><em>Poznámka. Obsah registrov AX a DX sme uchovali preto, lebo pri obsluhe prerušenia boli modifikované. V prípade, ak by sme ich neuchovali a prerušený program by ich po svojom pokračovaní použil, prišlo by k jeho nekorektnému správaniu sa.</em> </p><h4>4.4.5.2 Prenosy bez účasti procesora</h4><p><em>Prenos bez účasti procesora </em>sa vyznačuje tým, že <em>počas prenosu údajov riadi zbernicu počítača riadiaci obvod DMA a. procesor je od zbernice odpojený </em>(má svoje výstupy v stave vysokej impedancie). Údaje sa prenášajú<em> medzi pamäťou a V/V zariadením</em>. Tento spôsob prenosu sa tiež nazýva <em>priamy prístup do pamäte (DMA - Direct Memory Access)</em>a typicky sa používa na<em> blokový prenos údajov</em>, napr. pri práci s pevným diskom.<br />Ako riadiaci obvod <em>DMA </em>je použitý buď<em> špecializovaný programovateľný obvod</em>, alebo <em>špeciálny V/V procesor</em>.<br />Tento spôsob prenosu sa vykonáva vtedy, ak riadiaci obvod <em>DMA </em>vykonáva prenos údajov rýchlejšie ako procesor. Ďalej, program je podstatne jednoduchší, pretože procesor iba odovzdá riadiacemu obvodu <em>DMA </em>požiadavky na prenos a ďalej už len čaká na jeho vykonanie.<br />Treba si uvedomiť, že aj keď vlastný prenos údajov je bez účasti procesora, V/V prenos ako taký bol<em> inicializovaný procesorom</em>. Pred vlastným uskutočnením prenosu údajov musí procesor oznámiť riadiacemu obvodu <em>DMA </em>požiadavky na prenos<em>(odkiaľ a kam sa majú údaje prenášať a koľko ich má byť)</em>. Až potom riadiaci obvod <em>DMA požiada procesor o pridelenie zbernice </em>a keď mu ju procesor pridelí, vykoná vlastný prenos údajov. Po jeho ukončení<em> vráti riadenie zbernice späť procesoru</em>, ktorý môže pokračovať v činnosti.<br />Na obr. 4.35 je typická konfigurácia počítača so zbernicovou architektúrou. Je vyznačené pripojenie riadiaceho obvodu<em> DMA</em>, pripojenie signálu <em>žiadosti o zbernicu DRQ (DMA Request)</em>z riadiaceho obvodu <em>DMA </em>do procesora, ako aj pripojenie signálu <em>o pridelení zbernice DACK# </em><em>(DMA Acknowledge)</em> z procesora do riadiaceho obvodu<em> DMA</em>. </p><p>&#160;</p><div style="text-align: center"><img src="../files/obrazky/55.png" border="0" alt="55" width="521" height="160" /></div><br /><p>&#160;</p><div align="center">OBR. 4.35. Počítač s riadiacim obvodom DMA </div><p>&#160;</p><p>Na obr. 4.36 je nakreslený typický signálny sled pri prenose<em> DMA</em>. Riadiaci obvod <em>DMA </em>žiada procesor o pridelenie zbernice nastavením signálu <em>DRQ </em>do aktívnej úrovne. Procesor zbernicu uvoľní a oznámi jej pridelenie riadiacemu obvodu <em>DMA </em>tak, že nastaví signál <em>DACK#</em>áo aktívnej úrovne. Potom riadiaci obvod <em>DMA </em>prevezme riadenie zbernice a vykoná vlastný prenos údajov. Po jeho ukončení uvoľní zbernicu a procesoru to oznámi nastavením signálu <em>DRQ </em>do neaktívnej úrovne. Procesor reaguje nastavením potvrdzovacieho signálu <em>DACK#</em>do neaktívnej úrovne a opäť prevezme riadenie zbernice.<br />V obrázku sú vyznačené časové úseky, v ktorých riadi zbernicu procesor resp. riadiaci obvod <em>DMA</em>. Všimneme si, že istú dobu nemusí byť zbernica riadená. Aby neprišlo k neželanému zápisu do pamäte alebo V/V zariadenia, riadiace signály, aktívne v úrovni<em> log.O</em>, sa ošetrujú pripojením cez odpor <em>(pull-up resistor)</em> na napätie<em>+5V</em>. Tým je zabezpečená ich neaktívna úroveň v čase, keď zbernica nieje riadená ani procesorom, ani riadiacim obvodom DMA. </p><div style="text-align: center"><img src="../files/obrazky/56.png" border="0" alt="56" width="421" height="142" /></div><p>&#160;</p><p>&#160;</p><div align="center">OBR. 4.36. Signálny sled pri prenose DMA </div>
</body>

</html>
